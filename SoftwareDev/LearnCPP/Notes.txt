//Learn CPP
//---------

// General Resources
//------------------

https://www.w3schools.com/cpp/cpp_quiz.asp
https://www.geeksforgeeks.org/hard/cpp-gq/
https://www.geeksforgeeks.org/c-virtual-functions-question-2/
https://aticleworld.com/cplusplus-quiz/
https://www.cplusplus.com/reference/cstdlib/rand/
https://www.w3resource.com/cpp-exercises/basic/index.php#EDITOR

//------------------


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//https://www.youtube.com/watch?v=bFtkHJy9kIU&t=3798s
//70* Experienced C++ Interview Questions
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//------------------
//friend function
//------------------

//allow access into a class method from outside

//it is like declaring a function in a class without definition, then give definition from outside the class (use same func name to connect). this func definition will be able to access private members that belong to that class, but it will NOT have access to privates that are inherited

//friend is just your friend (class) and not you parents and g-parents (base classes)

class Base {
	int x;
public:
	Base() {}
	Base(int x):x{x} {}
	friend void func(Base &);
};

void fun(Base &obj) {
	cout << obj.x << endl;
	obj.x = 20;
}

void main() {
	Base b(10);
	fun(b);
	
	return 0;
}

//------------------


//------------------
//auto keyword in C++
//------------------

// automatically derive the type by the value assigned.
// not included in CPP legacy
// i integer, d double, <classname> class, p pointer

#include <iostream>
#include <typeinfo>
using namespace std;

class Base {};

int main() {
	auto x = 20;  
	auto y = 20.5;
	auto b = Base(); // init in stack
	auto c = Base(); // init at heap - pointer
	
	cout << typeid(x).name() << endl; // i
	cout << typeid(y).name() << endl; // d
	cout << typeid(b).name() << endl; // 4Base
	cout << typeid(c).name() << endl; // P4Base
	
	return 0;
}

//------------------


//------------------
//Code bloating. 
//------------------

//1. creating variables that are not required to have a life time
// creating a string var is not needed because we just print it. 
// instead, print the text directly.
#include <iostream>
using namespace std;
int main() {
	string str("EV");
	cout << str << endl;
	cout << "EV" << endl;
	return 0;
}

//1. inline function mass calls
// an inline function is copied at compile time.
// if there's a statement that do that, the code will bloat
#include <iostream>
using namespace std;
class Base {
	int _x;
public:
	inline void print() { /* some code */ }
}
int main() {
	Base b1;
	b1.print();b1.print();b1.print();b1.print();b1.print();
	return 0;
}


//------------------
//constant cast in CPP
//the expression const_cast<T>(v) can be used to change the const or volatile qualifiers of pointers or references.
//T must be a pointer, reference or pointer-to-member type

//RULES WHEN TO USE THIS
// 1 only when we have to
// 2 only when the actual refered obj/var is NOT const
// 3 only when dealing wiht 3rd party lib and some API want data in non const form but we have it in const form. we have to make sure the API doesn't make changes to it.

//------------------

// examples below will compile but will produce unexpected results.

// case 1:
#include <iostream>
using namespace std;

int main() {
	const int a1 = 10;
	const int *b1 = &a1;
	int *d1 = const_cast<int*>(b1);
	*d1=15; 
	cout << a1 << endl;  //print "10". the compiler will optimize and replace "a1" with "10"
	cout << *d1 << endl; //prints 15! should be the same
	
	int a2 = 20;
	const int *b2 = &a2;
	int *d2 = const_cast<int*>(b2);
	*d2=30;  // this will work because the original variable a2 is not constant, so there's no problem
	cout << a2 << endl;   // both will print the same value
	cout << *d2 << endl;
	
	return 0;
}


// case 2:
//if we want to pass a const var of our own to a 3rd party lib that needs to get a non-const var, then we can use the const_cast
// note that the function does not set anything into x which is important
void thirfPartyFunc(int* x) {
	int k = 10;
	cout << k+*(x);
}

int main() {
	const int x = 20;
	const int* px = &x;
	thirfPartyFunc(const_cast<int*>(px));
	thirfPartyFunc((px));  //this line will not compile
	return 0;
}


//case 3: remove the volatile modifier so a variable will be optimized
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}

//------------------






//------------------
// One of the usages of the keyword "decltype"
// It checks the type of the expression
//------------------

// in this example, the template return type is T2 which is the second param to the Typed func "add"
// the code will output 2.8 and then 2, this is inconsistant
#include <iostream>
using namespace std;

template<typename T1, typename T2>
T2 add (T1 a, T2 b) { 
	return a+b;
}

int main() {
	
	cout << add(1, 1.8) << endl;
	cout << add(1.8, 1) << endl;
	return 0;
}

//to solve this we can use "decltype" to automatically assert the type
//the code below will print 2.8 and then 2.8 which is desired
//decltype(a+b) figures out that one of the params are given in float so it has to elevate the other to float too.
#include <iostream>
using namespace std;

template<typename T1, typename T2>
auto add (T1 a, T2 b) -> decltype(a+b){ 
	return a+b;
}

int main() {
	
	cout << add(1, 1.8) << endl;
	cout << add(1.8, 1) << endl;
	return 0;
}
//------------------



//------------------
// **IMPORTANT!**
// what is the difference between a pointer and a reference
//------------------

// a reference is NOT a variable of its own, like pointers. it can be considered as an alias
// 1. (Mem Addr) have the same address as the var refered (unlike pointer)
// 2. (Reassignment) unlike pointers re-assignment of a reference is NOT possible 
// 3. (NULL) unlike pointers a reference MUST BE ASSIGNED A VALUE at declaration point!
// int &r; -> this is illegal.
// 4. (Arithmetic ops) unlike pointers, references cannot have arithmetic operations applied to.
// int &r = i;
// r++; // this is illegal!
// 5. (Indirection) a reference cannot have another reference refering to it, unlike pointers
// int i = 10;
// //pointer p can have indirect pointers pointing to it.
// int* p = &i;
// int **pp = &p;  //indirect pointer to pointer p
// int ***ppp = &pp;  //indirect pointer to pointer pp
// //references can only have 1 level reference. its like re-aliasing the same symbol
// int &r = i;
// int &rr = r; // this is ok. both rr and r with have THE SAME VALUE


#include <iostream>
using namespace std;

int main() {
	
	int i = 10;
	int &r = i; //this is a reference to i
	int *p = &i; //this is a pointer to i
	
	// print all three definition addresses
	// this will print that &i and &r have THE SAME ADDRESS, while &p will have a different address, since a pointer is a variable of its own
	cout << &i << '\t' << &r << '\t' << &p << endl;
	
	return 0;
}
//------------------



//------------------
// differences between range based for loops and for_each loops
// 1. 
// 2.
// 3.
// 4.
//------------------

#include <iostream>
#include <vector>
#incldue <algorithm>
using namespace std;

void print(int val) {cout << val <<endl; }

int main() {
	
	//  create and populate the array with simple for loop
	vector<int> vec;
	for (int i=0; i<5; i++) {
		vec.push_back(i);
	}
	
	// get each element into i (i is NOT an index but the value)
	// - cannot define the range or iteration
	for (int i: vec)
		cout << i <<endl;
	
	// giving a start point and end point at the vector, and then giving a anonimous function that will be executed for each element i.
	// - can define the range with  "vec.begin()+2" for ex
	for_each(vec.begin(), vec.end(), 
		[](int i) {
			cout << i <<endl;
		}
	);
	
	// same as above but giving a named function "print". the param type must match!
	for_each(vec.begin(), vec.end(), print);
	
	return 0;
}
//------------------



//------------------
// dynamic_cast int CPP
// syntax: dynamic_cast<Type_To_Cast_To>(Expression)
// used at runtime to find out correct down-cast
// 1. at least one virtual function at base class
// 2. if cast success it will return a value of Type_To_Cast_To
// 3. if cast fails - 
//    type_To_Cast_To is pointer type then a NULL pointer will be returned
//    type_To_Cast_To is a reference type then a std::bad_cast exception will be thrown.
// "down cast" = base->child | "up cast" = child->base
//------------------
#include <iostream>
using namespace std;

class Base {
	virtual void print() { cout << "Base" << endl; }
};
class Derived1: public Base {
	void print() { cout << "Derived1" << endl; }
};
class Derived2: public Base {
	void print() { cout << "Derived2" << endl; }
};

int main() {
	Derived1 d1;
	
	// this works - cast d1 down to Base class
	//NOTE - this is an "up" cast which is also legal. 
	Base *bp = dynamic_cast<Base*>(&d1); 
	// this will NOT work since bp is a pointer of type Base and it attemps to cast it up the wrong child type (was "Derived1" and tried to cast to "Derived2"
	//NOTE - this is a "down" cast which is also legal. 
	Derived2 *dp2 = dynamic_cast<Derived2*>(bp);  //dp2 = NULL
	
	// this cast will work
	Derived1 *dp3 = dynamic_cast<Derived1*>(bp); //dp3 = an object
	
	try {
		Derived1 &r1 = dynamic_cast<Derived1&>(d1); // this will pass
		Derived2 &r2 = dynamic_cast<Derived2&>(d1); // this will throw exception
	} catch (std::exception& e) {
		cout << e.what() << endl;
	}
	return 0;
}
//------------------



//------------------
// explicit constructor
// using explicit ctor helps avoid implicit call to the constructor
//------------------
#include <iostream>
using namespace std;

class Basese {
	int b_var;
public:
	Base() {}
	Base(int var) : b_var(var) {}
	//explicit Base(int var) : b_var(var) {}  // same ctor with explicit modifier
	void print() { std::cout << b_var << std::endl; }
}

void fun (Base b) {
	b.print();
}

int main() {
	
	// if the ctor "Base(int var)" does not have the "explicit" modifier, then the code below will compile and work.
	
	Base obj1(10); // normal ctor call
	Base obj2 = 20; // implicit call to the constructor "Base(int var)"
	// also works passing to functions
	fun(obj1); // normal ctor call
	fun(30); // implicit call to the constructor Base(int var)
	
	return 0;
}
//------------------



//------------------
// "extern c" in cpp code
// used when we want to include c code into our cpp code
// the issue arise since cpp compiler mangles (modifies) all function names (we can see the given symbols (names) by the compiler in the *.o files generated) to achieve overloading.
// the solution is to encapsulate the #include statment with the phrase "extern "C" {}
//------------------

#include <iostream>
// "cfile.h" is a c header file that contains a function "func".
// the included func will get its name changed at compile time
#include "cfile.h" 
// including it like this will prevent the compiler from modifying the func name 
extern "C" {
	#include "cfile.h"
}

using namespace std;
int main() {
	
	func();
	return 0;
}
//------------------



//------------------
// function chaining
// calling multiple methods on an object that each returns itself so the entire call chain can be written in one line.
//------------------
#include <iostream>
using namespace std;

class Base {
	int _a,_b;
public:
	Base& funcA(int a) { _a = a; return *this; }
	Base& funcB(int b) { _b = b; return *this; }
	void print() { cout << _a << "," << _b <<< endl; }
}
int main() {
	
	Base b;
	b.funcA(1).funcB(2).print(); 
	return 0;
}
//------------------



//------------------
// function hiding in c++
// when we define a function in a derived class where the base class has a func with the same name, but with different param type. the Base func will not be called
// to explicitly call it, we can use SCOPE RESOLUTION -> <instance>.Base::func(param)
// another way is to insert the base function func in the scope of the derived class, by using "using Base::func;" which puts the base class func visible at the derived class and so it makes it available
//------------------
// TODO
#include <iostream>
using namespace std;

class Base {
public:
	void func(int a) { cout << "Base" << endl; }
}
class Derived: public Base {
public:

	using Base::func; // adding this line will add the base class func into the derived scope
	
	void func(char c) { cout << "Derived" << endl; }
}
int main() {
	Derived d;
	
	d.func(1);
	d.func('a'); // this will not call the case function
	
	d.Base::func(1); // this will call the base func since we are using scope resolution
	
	return 0;
}
//------------------



//------------------
// function pointer
// stores an address of a function. 
//// good use case example -> passing the "qsort" function a "compare" function which will allow the "qsort" to be generic and be able to sort any type of array/structure.
qsort(Arr,ArrLength,elementSize,compare) //compare is a pointer to our own compare function


//// for function with signature 
int add(int a, int b) {return a+b;}
// defining a pointer to this function (define and assign address)
// must match the signature of the function to point to
int (*funcPTR)(int,int) = &add; // traditional way
int (*funcPTR)(int,int) = add; // new compiler's way
// using the pointer to call the function
int c = (*funcPTR)(1,2); // traditional way
int c = funcPTR(1,2); // new compiler's way

//// passing a function as an argument
int funcThatGetsPassedTheFuncPTR(int (*someFunc)(int,int)) {\
	return someFunc(3,4);
}
void main() {
	
	printf("%d", funcThatGetsPassedTheFuncPTR(add));
	
}

//// returning a function pointer as an agrument
int add(int a, int b) {return a+b;}
int sub(int a, int b) {return a-b;}

typedef int(*arithmeticFunc)(int,int); //define the type of the function that returns a airthmetic function by type, so it will be readable
arithmeticFunc getFunc(int type) {
	if (type == 1)
		return add;
	if (type == 2)
		return sub;
}
void main() {
	int (*someFunc)(int,int); // the pointer to our function
	someFunc = getFunc(1); // set the pointer to the add func
	printf("%d", someFunc(2,3)); // call it using the pointer and print.
}

//*******
// we can replace this
typedef int(*arithmeticFunc)(int,int);
arithmeticFunc getFunc(int type) { .. }
// with this
int (*getFunc (int type))(int,int) { .. }
//*******

//// using arrays of function pointers
int add(int a, int b) {return a+b;}
int sub(int a, int b) {return a-b;}
typedef int(*arithmeticFunc)(int,int);
void main() {
	arithmeticFunc funcArr[2] = {add, sub}; // array of two func pointers
	int added = funcArr[0](1,2);
	//int added = (*funcArr)[0](1,2);  //legacy 
	int subed = funcArr[1](1,2);
	//int subed = (*funcArr[1])(1,2);  //legacy 
}
//*******
// we can replace this
typedef int(*arithmeticFunc)(int,int);
arithmeticFunc funcArr[2] = {add, sub};
// with this
int (*funcArr[2])(int,int) = {add, sub};
//*******

//------------------



//------------------
// functor
// TODO: 1:38:45
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// what is gdb and how to use it to debug
// 1:40:50
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// what is compiler linker and loader
// TODO: 1:52:20

// diagram #1
//-------------------------------------------------------------------------------------
// source -> compiler -> obj |
// source -> compiler -> obj |-> linker -> [exectuable] -> loader -> [runnig exec in mem]
// source -> compiler -> obj |
//            [library file] |
//-------------------------------------------------------------------------------------

// diagram #2
//-------------------------------------------------------------------------------------
//									IDE (source code writing)
//										|
//										|	(.cpp, .h) source code and header files
//										|
//									preprocessor
//										|
//										|	(*.i) include files, replaced symbols
//										|
//									compiler
//										|
//										|	(*.s) assembly code
//										|
//									Assembler
//										|
//										|	(*.o) object code
//										|
//	static Libraries (.lib, .a) --->Linker
//										|
//										|	(.exe)
//										|
//	dynamic Libraries (.dll, .so)--->Loader
//										|
//										|
//										|
//									operating system
//-------------------------------------------------------------------------------------

//------------------



//------------------
// delete[] - how does delete[] (delete on array) knows the size of the array if we use a pointer?
// answer - at array init we give a size. at that point we store it somewhere.
// two ways to store it:
// 1. Over allocation - we add more memory to the array where we store that size, and at de-allocation time we get that size from there and de-allocate the entire block.
// 2. Associative array - maintaining a separate array where we store pointer+size ([*p, SIZE]) and at deallocation we search for that pair and take the SIZE from there.
//------------------
//TODO:
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// local static variable in a template function
//TODO:
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// "this" pointer in C++
// it is hiddenly passed as argument to non static member functions
// it is a const pointer [Type* const this]
// if the member function is const (in case of a "get" method for example where values are read but not write) than this pointer type is passed as const  [const Type* const this]
//------------------
//TODO:
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to assign any object to a primitive data type? 
// answer - define the operator <primitive_type>() in the class
// TODO: 2:26:14
//
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to call function before main
// TODO: 2:29:16
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to check if two different objects belong to the same class in c++
// answer - useing #include <typeinfo>
// TODO: 2:31:58
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to overload pre and post increment operator in c++
// TODO: 2:33:36
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to print N times without a loop or recursion
// print in class ctor and init an instance N times
// TODO: 2:38:50
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to set/clear/toggle/check one bit in of an integer var
// TODO: 2:40:14
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to stop an object from being copied
//------------------

// 1st way - keep copy constructor and assignment operator private
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
private:
	Base(const Base& obj): _x{obj._x} {}
	Base& operator = (const Base& rhs) { _x = rhs._x; return *this;}
};

int main() {
	Base b1(10);
	Base b2(20);
	
	Base b3(b1);	// -> this will produce an error 
	b1 = b2;		// -> this will produce an error 
	return 0;
}
//------------------

//------------------
// 2nd way - inherit dummy class with private copy constructor and assignment operator
// -> this will separate the Base class from the code that blocks the copy
#include <iostream>
using namespace std;

class StopCopy {
public:
	StopCopy() {}
private:
	StopCopy(const StopCopy& obj) {}
	StopCopy& operator = (const StopCopy& rhs) { return *this; }
};

class Base : public StopCopy {
	int _x;
public:
	Base() : _x{0} {}
	Base(int x) : _x{x} {}
};


int main() {
	Base b1(10);
	Base b2(20);
	
	Base b3(b1);	// -> this will produce an error 
	b1 = b2;		// -> this will produce an error 
	return 0;
}
//------------------

// 3rd way - delete copy ctor and assignment operator from your class - cleaner
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
	Base(const Base& obj) = delete;
	Base& operator = (const Base& rhs) = delete;
};

int main() {
	Base b1(10);
	Base b2(20);
	
	Base b3(b1);	// -> this will produce an error 
	b1 = b2;		// -> this will produce an error 
	return 0;
}
//------------------

//------------------
// how to prevant taking the address of my instance of an object

// 1st way: overload the reference (&) operator and set its visibily scope to private
//------------------
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
private:
	Base* operator & () { return this; }
};

int main() {
	Base b;
	cout << &b << endl;
	return 0;
}
//------------------

// 2nd way: delete the reference & operator from the class
//------------------
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
	Base* operator & () = delete;
};

int main() {
	Base b;
	cout << &b << endl;
	return 0;
}
//------------------



//------------------
// how to prevent inheriting from a class
// -> use "final" keyword on the base class that we wish to ceil.
// TODO: 3:00:30
//------------------
#include <iostream>
using namespace std;

class Base final {
	int _var1;
public:
	Base() {}
	Base(int var1) : _var1(var1) {}
};

class Derived: public Base {
	int _var2;
public:
	Derived() {}
	Derived(int var1, int var2): Base(var1), _var2(var2) {}
};

int main() {
	Derived d(1,2);
	return 0;
}
//------------------



//------------------
// how to write my own atoi func
//------------------
#include <iostream>
using namespace std;

int my_atoi(char *str) {
	
	if (str[0] == '\0')
		return 0;
	
	int res = 0;
	bool sign = true;
	int i = 0;
	
	if (str[0] == '-') {
		sign = false;
		i++;
	}
	else if (str[0] == '+')
		i++;
	
	while (str[i] != '\0') {
		if (str[i] < 48 || str[i] > 57)
			break;
		res = 10*res + str[i]-48;
		i++;
	}
	
	if (!sign)
		res = -res;
	
	return res;
}

int main() {
	
	cout << atoi("-1234") << "," << my_atoi("-1234") << endl;
	
	return 0;
}
//------------------



//------------------
// How vectors work internally in cpp STL
// -> capacity doubles everytime the size reach to capacity
//------------------
#include <iostream>
#include <vector>

using namespace std;

int main() {
	std:vector<int> vec;
	
	int i = 30;
	do {
		vec.push_back(i);
		cout << "capacity=" << vec.capacity() << endl;
		cout << "size=" << vec.size() << endl;
		i--;
	}while (i > 0);
	
	return 0;
}
//------------------



//------------------
// how to call a constructor and destructor explicitly
// for objects in the stack this should NOT be done explicitly!
//------------------
#include <iostream>
using namespace std;

class Base {
	int var;
public:
	Base () { cout << "ctor" << endl; }
	~Base () { cout << "dest" << endl; }
};

int main() {
	cout << "before nameless instance" << endl;
	Base(); // ** this is an interesting case. since the object is instantiated temporary (we do not give it any name as a variable), as soon as the next line is executed, this object is not pointed by anyone and so the constructor is immediately called
	cout << "after nameless instance" << endl;
	
	Base b; // explicit call to constructor
	b.~Base(); // explicit call to destructor -> should not do it because the object is in the stack and we want to compiler to handle the destruction of the object.
	
	
	return 0;
	
} /// -> here the instance "b" goes out of the scope and thus its destructor will be called again implicitly.


//------------------


//------------------
// cpp optimization checking website ->  https://godbolt.org
//------------------


//------------------
// function overloading - Name mangling
// compiler extends the symbols of the overloaded functions and so it compiles
//------------------
#include <iostream>
using namespace std;

void print(int val) {  } // this func name is renamed to  "_Z5printi"
void print(double val) {  }  // this func name is renamed to  "_<prefix>printd"

int main() {
	
	return 0;
}
//------------------



//------------------
// object slicing in cpp
// when creating a base object by copying from a derived object, the derived data will not be copied (duh..)
// in the example below, "Base b_obj = d_obj;" will copy only b_var data of d_obj into the b_var of the new b_obj.
// this is called object slicing because the derived objcet instance data is sliced into the base object instance
//------------------
#include <iostream>
using namespace std;

class Base {
public:
	int b_var;
	Base() { cout << "Base ctor" << endl; }
	~Base() { cout << "Base dest" << endl; }
};
class Derived: public Base {
public:
	int d_var;
	Derived() { cout << "Derived ctor" << endl; }
	~Derived() { cout << "Derived dest" << endl; }
};

int main() {
	Derived d_obj;
	Base b_obj = d_obj;	
	cout << "exit" << endl;
	return 0;
}
//------------------



//------------------
// efficient and cool algorithm to count '1' bits of a binary number
// amazing how it works
//------------------
#include <iostream>
using namespace std;

int numOnes_normal(int binNum) {
	
	int count = 0;
	while (binNum) {
		count += (binNum & 1);
		binNum >>= 1;
	}
	return count;
}
int numOnes_BrianKernighanAlgo(int binNum) {
	
	int count = 0;
	while (binNum) {
		binNum &= (binNum-1);
		count++;
	}
	return count;
}


int main() {
	for (int i=0; i<32; i++) {
		cout << "num=" << i << "\t(normal,BrianKernighanAlgo)= " << numOnes_normal(i) << ", " << numOnes_BrianKernighanAlgo(i) << endl;
	}
	return 0;
}
//------------------



//------------------
// override in cpp (cpp v11 and above)
// -> seems like override in cpp does not require the "override" keyword to override base fucntions.
// it is a good practice to put it because
// 1. testing becomes easy because the maintenance is easier
// 2. more important, a compile time check is performed and in case the overrided function signature does not match the virtual base one, and the override keyword was added, then the compiler will alert about the signature mismatch
//------------------
#include <iostream>
using namespace std;

class Base {
	int b_var;
public:
	virtual void fun() { cout << "base" << endl; }
}
class Derived {
	int d_var;
public:
	void fun() { cout << "derived" << endl; } // this already overides the base func
	void fun() override{ cout << "derived" << endl; } // nothing will change here.
	void fun(int a) { cout << "derived" << endl; } // here the signature mismatch so the base func is not overrided. the override keyword is not used here so the compiler won't alery
	void fun(int a) override{ cout << "derived" << endl; } // same mismatch but the override keyword is used so the compiler will alert
}

int main() {
	Base* b = new Derived();
	b->fun();
	return 0;
}
//------------------



//------------------
// placement new in C++
// -> when using the "new" keyword, we are switching to kernel mode from user mode to search for adequate space fot the new object. it is an overhead to the system in general. (switching to kernel is a hursh operation)
// if this is done many times, this overhead becomes a problem.
// -> the solution is to explicitely allocate memory for all the object instances that we required ahead of time. it is called a "memory pool".
// this way if we need 10 instances, we call the kernel only once to create the pool.
// -> create a memory pool (char[] memory) in the size of the class, times the amount of instances
// -> when creating each object, provide the address of the memory which the object will be placed into, in the memory pool. note that we have to set the memory location identation correctly. if the object size in byte is S, then each instantiation have to skip S bytes from the last object.
// finally when finishing using the pool (destructing all objects), we delete the pool itself
//------------------
#include <iostream>
using namespace std;

class Base {
public:
	Base() { cout << "ctor" << endl; }
	~Base() { cout << "dest" << endl; }
};

int main() {
	
	cout << "normal case" << endl;
	Base* obj = new Base();
	delete obj;
	
	
	cout << "placement new case" << endl;
	char* memory = new char[10*sizeof(Base)]; // Base size if 4 bytes so memory is 40 bytes
	Base* obj1 = new (&memory[0]) Base();
	Base* obj2 = new (&memory[4]) Base();
	Base* obj3 = new (&memory[8]) Base();
	
	obj1->~Base();
	obj2->~Base();
	obj3->~Base();
	
	delete[] memory;
	
	return 0;
}
//------------------



//------------------
// reinterpret_cast in C++
// TODO: 3:40:20
// -> this use is never safe for anything other than casting back to the original type
// -> if we use this cast then the code becomes "non-portable" -> meaning it is now specific hardware dependent since we are assuming how the HW is defining the types in the memory (int can be 2 can be 4 and can be 8 bytes for ex.). we are loosing the hardware abstraction.

// This is dangerous because it can typecast any pointer type to any other pointer type
//------------------
#include <iostream>
using namespace std;

class Mango {
public:
	void eatMango() { cout << "eating mango" << endl; }
};
class Banana {
public:
	void eatBanana() { cout << "eating banana" << endl; }
};
int main() {
	Banana* b = new Banana();
	Mango* m = new Mango();
	
	Banana* newBanana = reinterpret_cast<Banana*>(m);
	newBanana->eatBanana();
	
	return 0;
}
//------------------

// Good usage - if we want to treat a type data in a different way.
// in the example below we create an instance of the struct and then creating an int* pointer that points to it but as if it was an actual integer. this way we can access its memory structure as if it was an integer array.
// -> this reminds me of the Union keyword that allows to share the same memory with multiple structure definitions
//------------------
#include <iostream>
using namespace std;

struct myStruct {
	int x; // 4 byte
	int y; // 4 byte
	char c; // 2 byte
	bool b; // 2 byte
};

int main() {
	
	myStruct s;
	s.x = 5; s.y = 10; s.c = 'a'; s.b = true;
	
	int* p = reinterpret_cast<int*>(&s);
	
	cout << sizeof(s) << endl;
	
	cout << *p << endl; // will print s.x -> 5
	p++;
	cout << *p << endl; // will print s.y -> 10
	p++;
	cout << *p << endl; // will print (int)s.c + (int)true*0xFF -> 256 + 97 = 353
	
	// we can separate the character by doing reinterprete again to char
	
	char* c = reinterpret_cast<char*>(p);
	cout << *c << endl;
	
	// since the char pointer points to a 2 byte memory chunk, we can use it to point to the boolean after it. this is NOT possible using the integer pointer since it points to 4 byte chunks and we will skip over it.
	c++;
	bool* b = reinterpret_cast<bool*>(c);
	cout << *b << endl;
	
	return 0;
}
//------------------





//------------------
// static_cast in C
// TODO: 3:54:42
//------------------

// When to use and why:
// 1. when converting compatible types (e.x. float to int)
// 2. when calling conversion operator and conversion constructor
// 3. to avoid (and get a compiler error) when trying to convert unmatched types
// 4. to avoid conversion of derived instance into a private base pointer.
// 5. use always when up-casting (derived to base) but never use for down-casting (base to derived) - there's not runtime checks for static_cast conversions
// 6. explicitly defines casting intensions. make it easier to debug and manage (search)
// 7. errors are found at compile time which is very important.

// 6 examples below that illustrate these points:


// program 1
// performs implicit conversions between types
// easy to search and find all casts in the code.
// the cast will happend AT COMPILE TIME
#include <iostream>
using namespace std;

int main() {
	float f = 3.5;
	int a;
	
	// both below lines are doing THE SAME
	// searching for all casts is very easy when we use "static_cast"
	// this helps greatly to find and analyze casting in the code.
	a = f;
	a = static_cast<int>(f);
	
	return 0;
}
//------------------


// program 2
// used when conversion between types is provided with conversion operator or conversion constructor.
// 
#include <iostream>
using namespace std;

class Int {
	int x;
public:
	// conversion constructor - will be called when an instance gets an assignment to a value, as if it was of that primitive type. 
	Int(int x=0): x{x} { cout << "conversion constructor" << endl; }
	// conversion operator - will be called when a instance of this class is used as a string.
	operator string () {
		cout << "conversion operator" << endl;
		return to_string(x);
	}
};

int main() {
	Int obj(3);
	
	string str1 = obj;  // conversion operator is called implicitly
	obj = 20;	// conversion constructor is called implicitly
	
	// same happens here but we explicitly casting using the static_cast
	string str2 = static_cast<string>(obj); // conversion operator is called explicitly
	obj = static_cast<Int>(30);	// conversion constructor is called explicitly
	
	return 0;
}
//------------------


// program 3
// static_cast is more restrictive than C-style cast.
// e.x.  char* to int* is allowed in C-style cast but not with static_cast
#include <iostream>
using namespace std;

int main() {
	char c; 			// 1 byte data
	int *p = (int*)&c;  // 4 byte data
	*p = 5;				// compiles but fails are run-time - will allow access mem that should not be accessed
	
	int* ip = static_cast<int*>(&c); // FAIL at compile time!, because pointer types mismatch. this help avoid from the previous example
	
	return 0;
}
//------------------


// program 4
// static_cast prevents casting from derived class to a private base pointer
// ** private inheriting means that any class that inherit from the derived classs will not have access to its derived class
// i.e.
// assume: class Base {};  class Derived: private Base {};
// class Derived2: public Derived {};
// the class Derived2 will not have access to Base class elements

#include <iostream>
using namespace std;

class Base {};
class Derived: private Base {}; // the derivation here is private

int main() {
	Derived d1;
	Base* bp1 = (Base*)&d1; // this is allowed at compile time but IT IS NOT DESIRED!
	Base *bp2 = static_cast<Base*>(&d1);  // this will fail at compilation 
	return 0;
}
//------------------


// program 5
// static_cast used for all up-casts (cast derived to base), but should never be used for down-casts (cast base to derived), because with down-cast we don't know the true type of the instance. this is because up-cast we always have one parent but down-cast we can have many childs
// the example below will compile but it is incorrect!
#include <iostream>
using namespace std;

class Base {};
class Derived1: public Base {};
class Derived2: public Base {};

int main() {
	Derived1 d1;
	Derived2 d2;
	
	Base* bp1 = static_cast<Base*>(&d1); // upcast d1 to base pointer bp1
	Base* bp2 = static_cast<Base*>(&d2); // upcast d2 to base pointer bp2
	
	Derived1 *d1p = static_cast<Derived1*>(bp2); // downcast with a mixup. d2->d1
	Derived2 *d2p = static_cast<Derived2*>(bp1); // downcast with a mixup. d1->d2
	
	return 0;
}
//------------------


// program 6
// static_cast is recommended when casting to and from a void* pointer
#include <iostream>
using namespace std;

int main() {
	int i = 10;
	void* v = static_cast<void*>(&i);
	int* ip = static_cast<int*>(v);
	return 0;
}
//------------------





//------------------
// structural padding & packing in C & CPP
// TODO: 4:10:15
// -> the padding i was working on in the protocol message structures. packing removes the padding which wastes memory but optimize read because reading is simpler. (padding in structure is by the largest element defined inside it. also, when defining a structure within a structure, the padding will be by the largest primitive, within the inner strucure as well as the outer stcruture.
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// difference between Enum & Enum class
// TODO: 4:36:55
// -> class simply adds scope so the names of the enum values are separated from other types.
// -> also, class enum values cannot be converted to integers easly (like normal enums, which always takes by default the values 0, 1, 2, etc)
// -> if we define two separate regular enum which does not have any connection in terms of meanings, they could still be compared (because of the default values described above).
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// Two Ways To Return Multiple Values From Functions In C++
// 4:46:53 
// -> normal is to define a struct that will hold these values.
// -> other way is to use tuples. we can declare the output variables outside and then pass them into as a tuple, or we can use the "auto" keyword and then use the "get" and the value position in the tuple to retrieve the values.
//------------------
#include <iostream>
#include <string>
#include <tuple>
using namespace std;

tuple<int, char, string> fun() {
	return make_tuple(1,'a',"str");
}
int main() {
	
	int n, char c, string s;
	auto tup = fun();
	n = get<0>(tup);
	c = get<1>(tup);
	s = get<2>(tup);
	
	return 0;
}
//------------------



//------------------
// Virtual Destructor In C++?
// 4:51:43 
// ctors are called by what type of object their pointer hold, but dests are called by the type of the pointer!

//------------------
#include <iostream>
using namespace std;

class Base {
public:
	virtual void fun() { cout << "Base fun" << endl; }
	Base() { cout << "Base ctor" << endl; }
	~Base() { cout << "Base dest" << endl; }
	//virtual ~Base() { cout << "Base Dest" << endl; }
	// if we make the dest virtual then the derived dest will be called also (the derived dest and then the base)
};
class Derived : public Base {
public:
	virtual void fun() { cout << "Derived fun" << endl; }
	Derived() { cout << "Derived ctor" << endl; }
	~Derived() { cout << "Derived dest" << endl; }
};

int main() {
	// b1 is of type Base and is held by a Base pointer - Base ctor will be called
	Base* b1 = new Base(); 
	// b2 is of type Derived and is also held by a Base pointer - Derived ctor will be called
	Base* b2 = new Derived();
	
	b1->fun();// will call the Base fun version
	b2->fun();// will call the Derived fun version
	
	delete b1; // this will call the Base dest
	delete b2; // ** if the Base dest is not virtual, then this will not call the Derived dest!
	
	return 0;
}
//------------------



//------------------
// Where do we HAVE to use Initialiser List In C++?
// 4:57:14 
//------------------


// case 1: when we want to init a non-static const member of a class, we must use init list and we cannot do it within the ctor itself.
#include <iostream>
using namespace std;

class Base {
	const int _x;
public:
	Base() : _x{0} {}
	Base(int x) : _x{x} {}
	//Base() { _x=0; }  //-> this will give a compiler error
	//Base(int x) { _x=x; }   //-> this will give a compiler error
};
int main() {
	Base b1(10);
	Base b2(20);
	
	return 0;
}


// case 2: when we want to init a non-static reference that is a member of a class, we must use init list and we cannot do it within the ctor itself
#include <iostream>
using namespace std;

class Base {
	int& _x;
public:
	Base() : _x{0} {}
	Base(int x) : _x{x} {}
	//Base() { _x=0; }  //-> this will give a compiler error
	//Base(int x) { _x=x; }   //-> this will give a compiler error
};
int main() {
	Base b1(10);
	Base b2(20);
	
	return 0;
}


// case 3: when we want to init one class type with another class type, we must use init list if the first class type does not have a default ctor.
#include <iostream>
using namespace std;

class One {
	int _x;
public:
	//One( : _x{0} {} // a default ctor 
	One(int x) : _x{x} {}
};
class Two {
	One _a;
public:
	Two(One x) : _a{x} {}
	// Two(One x) {_a = x;}  -> this will not work unless "One" will have a default ctor
};

int main() {
	One one(10);
	Two two(one);
	
	return 0;
}


// case 4: when we want to init a Base class members when calling a Derived class.
#include <iostream>
using namespace std;

class Base {
	int _b;
public:
	Base(int b) : _b{b} {}
};
class Derived : public Base {
	int _d;
public:
	Derived(int b, int d) : Base{b}, _d{d} {}
	//Derived(int b, int d) { _b=b; , _d=d; } -> this will not work
};

int main() {
	Derived d(1,2);
	return 0;
}


// case 5: when the name of a ctor parameter matches the member name itself (not _x=x  but _x=_x)
#include <iostream>
using namespace std;

class Base {
	int _b;
public:
	Base(int _b) : _b{_b} {}
	//Base(int _b) { _b=_b; } // this will obviously won't work.
};

int main() {
	Base b(1);
	return 0;
}


// case 6: when in one class we have a member of another type of class that is used by a ctor to init itself, if we do not use the init list then it will create a copy of that another class, adding an overhead. by using the init list we do not make a copy of the given another class at init time.
#include <iostream>
using namespace std;

class Another {
	int _x;
public:
	Another () { cout << "another default ctor" << endl; }
	Another (int x) { _x=x; cout << "another parameter ctor" << endl; }
	Another (const Another& obj) { this->_x = obj._x; cout << "another copy ctor" << endl; }
	Another& operator = (const Another& obj) { cout << "another assignment operator" << endl; }
};
class MyClass {
	Another _a;
public:
	MyClass() { cout << "MyClass default ctor" << endl; }
	
	// output:
	//another parameter ctor
	//another copy ctor
	//another copy ctor
	//MyClass parameter ctor
	MyClass(Another a) : _a{a} { cout << "MyClass parameter ctor" << endl; }
	
	// output:
    //another parameter ctor
    //another copy ctor
    //another default ctor
    //another assignment operator
    //MyClass parameter ctor
	//   MyClass(Another a) { _a=a; cout << "MyClass parameter ctor" << endl; }
};

int main() {
	Another a(1);
	MyClass mc(a);
	
	return 0;
}

//------------------



//------------------
// What Are The Drawbacks Of Using Vector In C++?
// TODO: 5:11:42 
// vectors use simple arrays in the background, so the following happens
// 1. it over allocates memory (capacity grows by factor of two)
// 2. when the capacity changes (doubles), it COPIES ALL ELEMENTS from PREVIOUS vector to a new vector!
//------------------
#include <iostream>
#include <vector>
using namespace std;

int main() {
	vector<int> vec;
	
	for (int i=0; i<100; i++) {
		cout << "size: " << vec.size() << "\tcap: " << vec.capacity() << "\taddr: " << &vec << endl;
		vec.push_back(i);
	}
	return 0;
}
//------------------



//------------------
// What Is Constructor Delegation In C++?
// 5:16:19 
// -> similar to ctor in C# where we chain constrctor call to another constructor to reuse the same code.
// not only the initilization of the members will be written once, but all the other initialization required will be written into ctor3 just once.
//------------------
#include <iostream>
using namespace std;

class Base {
	int _a, _b;
public:
	Base(): Base{0,0} {}   //ctor1 -> calls ctor3(0,0)
	Base(int a): Base{a,0} {}   //ctor2 -> calls ctor3(a,0)
	Base(int a, int b): _a{a}, _b{b} {}   //ctor3  -> list init _a & _b
};

int main() {
	Base b1();
	Base b2(10);
	Base b3(10,20);
	return 0;
}
//------------------



//------------------
// What Is Return Value Of printf And scanf In C & C++?
// 5:20:21 
// printf returns the number of characters that were printed
// scanf returns the number of elements that were read from the console , where elements are basically lines
//------------------
#include <iostream>
#include <stdio.h>
using namespace std;

int main() {
	int printOut = printf("%s", "hello world\n"); //12 chars
	cout << printOut << endl;
	
	char str[100];
	int scanIn = scanf("%s", str); // 1 element scanned
	cout << scanIn << endl;
	int val;
	scanIn = scanf("%s %d", str, &val); // 2 elements scanned
	cout << scanIn << endl;
	
	return 0;
}
//------------------



//------------------
// What Is RVO And NRVO Copy Elision In C++?
// 5:22:18 
// RVO - return value optimization
// NRVO - named return value optimization
// -> when compiling there's a flag that can disable some optimization invlovling calling copy constructor without any real need.
// -fno-elide-constructors
// adding this switch  to the compile command will cause the example below to output
// ctor
// copy ctor
// copy ctor
// this is because it disabled the optimization and the function call and the assignment are both calling the copy constructor 
//------------------
#include <iostream>
using namespace std;
class Base {
public:
	Base() { cout << "ctor" << endl; }
	Base(const Base&) { cout << "copy ctor" << endl; }
};
Base func() { 
	return Base();
}
int main() {
	Base b = func();
	return 0;
}
//------------------



//------------------
// What Is The Best Place To Use Enum In C++?
// 5:26:15 
// -> when we know beforehand the entire set of possible values for a specific problem. for ex - colors.
//------------------
#include <iostream>
using namespace std;

enum class Color {red, blue, green, };
void fun(Color c) {
	switch (c) {
		case Color::red: cout << "red" << endl; break;
		case Color::blue: cout << "blue" << endl; break;
		case Color::green: cout << "green" << endl; break;
	}
}
int main() {
	fun(Color::red); fun(Color::blue); fun(Color::green);
	return 0;
}
//------------------



//------------------
// What Is The Difference Between struct And class In C++?
// 5:28:42 
//------------------
// 1. memebr default visibility is private for classes and public for structs
#include <iostream>
using namespace std;

class classBase {
	int _c;
};

struct structBase {
	int _s;
};
int main() {
	classBase cb;
	structBase sb;
	cout << sb._s << endl;
	cout << cb._c << endl; // should not work
	return 0;
}
// 2. inheritance default visibility is private for classes and public for structs
#include <iostream>
using namespace std;

class BaseClass {};
class DerivedClass: private BaseClass; // the private here is not required

struct BaseStruct {};
struct DerivedStruct: public BaseStruct; // the public here is not required

int main() {
	return 0;
}
//------------------



//------------------
// What Is The Order Of Function Parameter Evaluation In C++?
// 5:32:10 
// -> the order of parameter evaluation is un-defined! it is up to the compiler to decide. what is promised is that all parameters will be evaluated BEFORE the call to the function (duhh..)
// executing the example below in 
// "https://www.programiz.com/cpp-programming/online-compiler/"
// shows that calling a function with two params, th SECOND param is evaluated first and only then the FIRST param will.
//------------------
#include <iostream>
using namespace std;

int param1() { cout << "param1" << endl; return 1; }
int param2() { cout << "param2" << endl; return 2; }
void func1Param(int a) { cout << a << endl; }
void func2Params(int a, int b) { cout << a << ", " << b << endl; }
int main() {
	func1Param(param1() + param2());
	func2Params(param1(), param2());
	return 0;
}
//------------------



//------------------
// When To Use Reference Over Pointer and Vice Versa In C++?
// 5:34:48 

// -> REFERNCE: use in func params and return types.
//-------------------------------------------

// 1. (optional usage) pass big objects by reference
#include <iostream>
using namespace std;
class BigClass { public: int _data; /* a lot of data */ };
void funcV(BigClass obj) { } // pass by value - will copy the entire object
void funcR(BigClass& obj) { obj._data; } // using a reference - to pass the big object by ref 
void funcP(BigClass* obj) { obj->_data; } // using a pointer - will have to use the arrow operator which is less nice.
int main() {
	BigClass obj;
	funcV(obj);
	funcR(obj); // pass with reference also allows us to not use the & symbol
	funcP(&obj);
	return 0;
}

// 2. (optional usage) avoid object slicing
#include <iostream>
using namespace std;

class Base {
public: virtual void print() { cout << "base print" << endl; }
};
class Derived: public Base {
public: virtual void print() { cout << "derived print" << endl; }
};
void funcV(Base obj) { obj.print(); }  // by val - will slice the object
void funcR(Base& obj) { obj.print(); } // by ref - will keep the object

int main() {
	Derived d;
	funcV(d); // will print the base - object sliced
	funcR(d); // will print the derived - object maintained
	return 0;
}

// 3. (optional usage) modify local vartiable of caller function (common use)
#include <iostream>
using namespace std;
void funcModifyVar(int& val) { val = val+10; }
int main() {
	int val = 1;
	funcModifyVar(val);
	cout << val << endl;
	return 0;
}

// 4. (optional usage) achieve runtime polymorphism in a function (similar to obj slice)
#include <iostream>
using namespace std;

class Base {
public: virtual void print() { cout << "base print" << endl; }
};
class Derived: public Base {
public: virtual void print() { cout << "derived print" << endl; }
};
void func(Base& obj) { obj.print(); } // same function can get two varients and call different functions in one line - polymorphism

int main() {
	Base b; Derived d;
	func(b); func(d); 
	return 0;
}

// 5. essential usage - in copy constructors we MUST use references
#include <iostream>
using namespace std;

class Base {
	int _x;
public: 
	Base (int x): _x{x} {}
	Base (const Base& b): _x{b._x} {}  // copy constructor - must pass the copied object by ref
	void print() { cout << "x=" << _x << endl; }
};
int main() {
	Base b(5);
	Base b1 = b;  //call to copy constructor
	b.print(); b1.print();
	return 0;
}


// -> POINTERS: use in algorithms and data structures like linked-lists, trees, graphs, etc.
//-------------------------------------------
// 1. its possible to put null in a pointer (ref does not allow)
// 2. its possible to change pointer address (ref pointed address is constant)



//------------------
// Which Is Faster pre OR post Increment With Proof In C & C++?
// 5:43:20 
// use godbolt.org to analyze the code below in assembly to see the difference
// basically since we first add to i and then set its value to j, it takes one assembly atom command less.
//------------------
#include <iostream>
using namespace std;

int main() {
	int i = 10;
	int j = 20;
	j = i++; // post-increment
	j = ++i; // pre-increment
	return 0;
}
//------------------



//------------------
// Why Copy Constructor Take Argument As Reference?
// 5:48:36 
// the reason is very interesting. passing an object by value to a function will incure a copy of the object (pass by value always copy the parameter being passed).
// a copy constructor must get an instance of an object to use its data to copy.
// this means that if we pass the object to copy to the copy constructor value, it will incure a copy which means the same copy constructor will be called AGAIN!
// this will cause an infinite loop 
//------------------
#include <iostream>
using namespace std;

class Foo {
	int _bar;
public:
	Foo() {}
	Foo(const Foo& obj) { _bar = obj._bar; }
	//Foo(const Foo obj) { _bar = obj._bar; }  // pass by value will incure a copy which will create an infinite loop..
	void setBar(int newBar) { _bar = newBar; }
};
int main() {
	Foo f1;
	f1.setBar(5);
	Foo f2 = f1;
	return 0;
}
//------------------



//------------------
// Why Must Define Static Data Member of Class In Cpp File?
// 5:51:16 
// -> it will create "multiple definitions" compile time error
// this is because the "foo.h" header is included twice - in app.cpp and in foo.cpp.
// these multiple includes will create multiple definitions error
// the correct way is to declare at the header file and define at the code file
//------------------
#include <iostream>
#include "foo.h"
using namespace std;

//FILE: app.cpp 
int main() {
	Foo obj1, obj2;
	o1.setNormal(10); // o1 - own memory for normalVariable
	o2.setNormal(5);  // o2 - own memory for normalVariable
	// o1 and o2 will have common memory for staticVariable (a trait of static vars)
	cout << o1.getNormal() << endl;
	cout << o2.getNormal() << endl;
	
	o1.setStatic(60);
	cout << o2.getStatic() << endl;
	return 0;
}
//FILE: app.cpp END

//FILE: foo.cpp 
#include "foo.h"

int Foo::staticVariable = 10;  ///*** defining here will avoid the multiple definitions

Foo::Foo() { normalVariable = 0; }
Foo::Foo(const Foo& obj) { normalVariable = obj.normalVariable; }

void Foo::setNormal(int newVal) { normalVariable = newVal; }
int Foo::getNormal() { return normalVariable; }

void Foo::setStatic(int newVal) { staticVariable = newVal; }
int Foo::setStatic() { return staticVariable; }
//FILE: foo.cpp END

//FILE: foo.h 
class Foo {
	int normalVariable;
	static int staticVariable;
public:
	Foo();
	Foo(const Foo&);
	void setNormal(int);
	int getNormal();
	void setStatic(int);
	int getStatic();
};

int Foo::staticVariable = 10; ///*** defining here will create multiple definitions

//FILE: foo.h END

//------------------



//------------------
// Why Prefer Pass By Reference Or Pointer Over Pass By Value?
// 5:54:08 
// save us from copying big objecs
//------------------
#include <iostream>
#include <vector>
using namespace std;

#define size 1000

//void foo(vector<int> vec) { // pass the vec by value - make a copy!
//void foo(vector<int>& vec) {  // this is the correct way - pass the vec by ref
void foo(const vector<int>& vec) {  // tpass by ref and also make it const. this is good if  the function only read values and do not change anything
	for (auto v: vec) { 
		cout << v << ", ";
	}
	cout << endl;
}
int main() {
	vector<int> vec(size);
	for (int i=0; i<size; i++) {
		vec[i] = i+1;
	}
	foo(vec);
	return 0;
}
//------------------



//------------------
// Why Returning Reference Is Bad Some Time In C++?
// 5:57:30 
// -> when returning a reference of a local variable it is not good since the variable will be removed when the function returns, so the reference is meaninigless
// the code below will result in a compiler error
//------------------
#include <iostream>
using namespace std;

int& func() {
	int a = 10;
	return a;
}
int main() {
	int& a = fun();
	cout << a << endl;
	return 0;
}

//the code below will work because we are giving a reference and returning the same reference
#include <iostream>
using namespace std;

int& func(int& i) {
	i += 10;
	return i;
}
int main() {
	int i = 5;
	cout << i << endl;
	int& a = func(i);
	cout << a << endl;
	return 0;
}
//------------------



//------------------
// Why Size Of Empty class OR struct Is One In C++?
// 6:00:23 
// empty structures and classes size in CPP is NOT ZERO. it is 1! why?
// this is because if there's nothing to differentiate between instances (i.e. values of members) then the compiler must insert something to differentiate!
// if we will add a simple integer, the size will be 4 (integer size) and not 5 (integer+1)
//------------------
#include <iostream>
using namespace std;
struct EmptyS {};
class EmptyC {};
int main() {
	cout << sizeof(EmptyS) << endl;
	cout << sizeof(EmptyC) << endl;
	return 0;
}
//------------------



//------------------
// Why Template Functions Only Defined Inside Header Files?
// 6:04:54 
// TODO  - what is the reason?
//------------------

/// in the example below the declaration of the template is on the header, but the definition is on the code file. this will NOT compile.
/// -> to make it compile we must put the definition as well as the declaration into the header.
/// but this is unwanted since we mix declaration and definition into the same file!
/// -> (solution I) one way to solve this we can keep the definition in the code file and simply use "#include" in the header file, right after the declaration.
/// -> (solution II) another way is to instantiate specific types for the class template so that the compiler won't have to create them and in this process re-create the issue.



//FILE: foo.h 

#ifndef foo_h
#define foo_h

#include <iostream>
/// DECLARATION
template<typename T> 
class Foo {
	T _val;
public:
	T getValue();
	void setValue(T val);
};
/// DECLARATION END

///** the DEFINITION should be here so the project will compile

/// (solution I) use include
#include "foo.cpp"

#endif

//FILE: foo.h END


//FILE: foo.cpp 

#include "foo.h"
/// DEFINITION
template<typename T> 
T Foo::getValue() { return _val; }
void Foo::setValue(T val) { _val = val; }
/// DEFINITION END

/// (solution II) define class templates with specific types that we are going to be using
template class Foo<int>;  // define a class template for int type
template class Foo<float>;  // define a class template for float type
// ....


//FILE: foo.cpp END


//FILE: app.cpp 
#include "foo.h"
using namespace std;
int main() {
	Foo<int> obj;
	obj.setValue(5);
	cout << obj.getValue() << endl;
	return 0;
}
//FILE: app.cpp END


//------------------




//------------------
// Why Using Namespace Std Is Bad To Use?
// 6:11:24
// -> the question is actually - why putting the line "using namespace std;" and then using "cout" for example, without the namespace prefix "std" ("cout << .." instead of "std::cout << ...")
// the reason is because we might get a name collision with other libraries that might get included in the future which would have some elements that carry the same names.
// basically it is a good practice to write everything with the namespace prefix before any call to that namespace, instead of just putting the "using namespace .." clause
//------------------

// instead of this
#include <iostream>
using namespace std;
int main() {
	cout << "test" << endl;
	return 0;
}
// do this
#include <iostream>
int main() {
	std::cout << "test" << std::endl;
	return 0;
}

//------------------




//------------------
// Why vector Was Introduced In C++?
// 6:14:17 
// -> it is using arrays in conjunction with linkedlists
//  when a vector has to increase its capacity, a linked list structures is used. increasing capacity using an array structures is not optimized.
//  when accessing an element at specific index, an array structures is used. using a linkedlist structures to access an element at specific index is not optimized
// in conclusion, we get the benefits from both data structures
//------------------
#include <iostream>
#include <vector>

int main() {
	std:vector<int> vec;
	
	std::cout
	return 0;
}
//------------------



//------------------
// Why We Return Reference from Copy Assignment Operator?
// 6:16:59 
// -> this allows us to do assignment chaining 
//------------------
#include <iostream>
using namespace std;
class Base {
	int _var;
public:
	Base() {}
	Base(int val): _var{val} {}
	Base& operator = (const Base& rhs) { 
		_var = rhs._var;
		return *this;
	}
	void print() { cout << _var << endl; }
};

int main() {
	Base b1(10);
	Base b2, b3, b4;
	
	// chaining the assignments.
	// b4 is set to b1, and b4 ref is returned
	// b3 is set to b4, and b3 ref is returned
	// b2 is set to b3, and b2 ref is returned (but the ref is not used - end of chain)
	b2 = b3 = b4 = b1;
	// print all 
	b1.print(); b2.print(); b3.print(); b4.print();
	
	return 0;
}
//------------------



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
https://www.youtube.com/watch?v=zUy66Bats5c
Threading In C++ | Complete Course
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//------------------
// Introduction
// 00:00:00 - 
// * main is a default thread for the process of our program, from which we "fork" (create) more threads.
// * a thread is in some terms a lightweight process. unlike process, it shares memory with other threads.
// * creating a thread (c++11 and above) is achieved with Function pointers, Lambda fucntions, functors member functions and static member functions.
//
//------------------

// example - sum all odd numbers and even numbers, in a given large range
// when using threads we get parallel execution which shortens the exec' time

#include <iostream>
#include <thread>  // c++11 and above
#include <chrono>  // to measure exec' time
#include <algorithm>

using namespace std;
using namespace std::chrono;

typedef unsigned long long ull;  // shorthand alias

ull evenSum = 0;
void findEven(ull start, ull end) {
	for(ull i = start; i<= end; ++i) {
		if ((i & 1) == 0) {
			evenSum += i;
		}
	}
}
ull oddSum = 0;
void findOdd(ull start, ull end) {
		for(ull i = start; i<= end; ++i) {
		if ((i & 1) == 1) {
			oddSum += i;
		}
	}
}

int main() {
	ull start = 0, end = 2000000000;
	
	cout << "executing without threads..." << endl;
	auto startTime = high_resolution_clock::now();
	
    findEven(start, end);
    findOdd(start, end);
	
	auto duration = duration_cast<microseconds>(high_resolution_clock::now() - startTime);
	
	cout << "odd sum = " << oddSum << endl;
	cout << "even sum = " << evenSum << endl;
	cout << "duration = " << duration.count()/1000000.0 << endl;
	
	
	cout << "executing with threads..." << endl;
	startTime = high_resolution_clock::now();
	
	oddSum = evenSum = 0;
	// create and start running findEven & findOdd
	std::thread tEven(findEven, start, end);
	std::thread tOdd(findOdd, start, end);
	// join both threads to main thread - meaning it will block the main thread until both threads finished
	tEven.join();
	tOdd.join();
	
	duration = duration_cast<microseconds>(high_resolution_clock::now() - startTime);
	
	cout << "odd sum = " << oddSum << endl;
	cout << "even sum = " << evenSum << endl;
	cout << "duration = " << duration.count()/1000000.0 << endl;

	return 0;
}
//------------------





//------------------
// Different Types To Create Threads In C++11
// 00:18:00 - 
//------------------

// 1. with function pointer
//------------------
#include <iostream>
#include <thread>  // c++11 and above

void fun(int x) {
	while (x --> 0) {
		std::cout << x << std::endl;
	}
}
int main() {
	std::thread t(fun, 10);  // function name is used as the pointer
	t.join();
	
	// creating multiple threads - no guarantee which will start first
	std::thread t1(fun, 10);
	std::thread t2(fun, 20);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------

// 2. Lambda function
//------------------
#include <iostream>
#include <thread>

int main() {
	
	// injecting lambda expression directly to main
	auto fun = [](int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
	};
	
	std::thread t(fun, 10); // call the lambda function
	t.join();
	
	return 0;
}
//------------------

// 3. Functor (function object) - using a class special "()" operator to define its functionality as a runnable class.
//------------------
#include <iostream>
#include <thread>

class Base {
public:
	void operator ()(int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
	}
};

int main() {
	std::thread t(Base(), 10);  // pass the class as the function
	t.join();
	return 0;
}
//------------------

// 4. Non-static member function
//------------------
#include <iostream>
#include <thread>

class Base {
    int _y;
public:
    Base() {}
    Base(int y): _y{y} {}
	void run(int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
		std::cout << _y << std::endl;
	}
};

int main() {
	Base b(50);
	// creating the thread. passing the member function of the base as the function pointer (using reference because its a class). since its a non-static function, we need to also pass the class instance so we pass &b. we send it by reference to avoid copying the object
	std::thread t(&Base::run, &b, 10);
	t.join();
	
	return 0;
}
//------------------

// 5. Static member function
//------------------
#include <iostream>
#include <thread>

class Base {
public:
	static void run(int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
	}
};

int main() {
	Base b;
	// creating the thread. passing the member function of the base as the function pointer (using reference because its a class). since its a static function, we dont need to send and instance of an object
	std::thread t(&Base::run, 10);
	t.join();
	
	return 0;
}
//------------------




//------------------
// "Join", "Joinable" & "Detach" In C++11 Threading
//TODO: 00:25:32 - 

// Join. once a thread has started, calling "join" will block the current execution flow and wait for it to finish
// It is possible to ask if a thread is "joinable" meaning if a join call was not called upon it already.
// "joinable" is used to avoid calling join on a thread that has finished or did not start, which means it is not joinable. calling join on it on situations like this will terminate the program.
// IMPORTANT! if any thread will not get a call to either join or detach, then if the thread is still running and the program exits, it will call the thread's destructor which will check if it is still joinable and if so, it will terminate it.
//------------------
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void run(int x) {
	while ( x--> 0)
		cout << x << endl;
	this_thread::sleep_for(chrono::seconds(3));
	cout << "thread finished" << endl;
}
int main() {
	// t1 JOIN
	thread t1(run, 5);
	cout << "before t1 join" << endl;
	t1.join();
	cout << "after t1 join" << endl;
	// here the thread has already finished. if we call join again it will terminate the entire program
	
	// t2 JOINABLE
	thread t2(run, 5);
	cout << "before t2 is joinable" << endl;
	t2.join();
	if (t2.joinable()) {
		cout << "is joinable" << endl;  // will be printed if the previous join is commented.
		t2.join();
	}
	cout << "after t2 is joinable" << endl; // this will print after the thread will finish, proving join is blocking the main thread.
	
	// t3 DETACH
	thread t3(run, 5);
	cout << "before t3 detach" << endl;
	if (t3.joinable()) {  // only detach if joinable
		t3.detach(); // we call detach which will exit the program before t3 will end
	}
	cout << "after t3 detach" << endl; // this will be printed immediately, and t3 will not get to print its output
	
	this_thread::sleep_for(chrono::seconds(4)); // if we sleep for more than 3 secs before main exists, then t3 will get to finish its job and print its output
	
	cout << "program finished" << endl;
	return 0;
}
//------------------





//------------------
// Mutex In C++ Threading
// 00:42:41 -
//  Race condition - when two threads are trying to change shared data in parallel. obviously it is an issue.
// Critical section - a section of code that r/w shared data and might run in parallel and thus expose a chance of race condition.
// Mutex (mutual exclusive) - a binary semaphore that is used to control access to critical section, such that only one thread can execute it at a time.
// Mutex has two functions - lock and unlock (release). 
//------------------
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int moneyAmount = 0;

void addMoney() {
    for (int i=0; i<1000000; ++i)
        ++moneyAmount;
}

std::mutex m;
void addMoneyThreadSafe() {
    m.lock();
    for (int i=0; i<1000000; ++i)
        ++moneyAmount;
    m.unlock();
}

int main() {

    std::thread t1(addMoney);
    std::thread t2(addMoney);
    t1.join();
    t2.join();
    cout << "not safe result: " << moneyAmount << endl;

    moneyAmount = 0;
    std::thread t1ts(addMoneyThreadSafe);
    std::thread t2ts(addMoneyThreadSafe);
    t1ts.join();
    t2ts.join();
    cout << "thread safe result: " << moneyAmount << endl;

    return 0;
}
//------------------




//------------------
// Mutex Try Lock
// 00:58:56 - 
// mutex.try_lock() attempts to lock the mutex. it returns immediately with true or false, where if returned true, the mutex is promised to be locked.
// try_lock() is non blocking (as opposed to lock()) - it returns immediately.
// if try_lock() is called again by the same thread after already returned true, it will produce an undefined behaviour, basically a "dead-lock". (there is a possibility to lock a mutex more than once, called recursive_mutex)
//
// there are various try_lock function
// 1. std::try_lock
// 2. std::mutex::try_lock
// 3. std::shared_lock::try_lock
// 4. std::timed_mutex::try_lock
// 5. std::unique_lock::try_lock
// 6. std::shared_mutex::try_lock
// 7. std::recursive_mutex::try_lock
// 8. std::shared_time_mutex::try_lock
// 9. std::recursive_timed_mutex::try_lock
//
//------------------

// 2. std::mutex::try_lock  (lock method of a single mutex)
// since we only try to lock, some iterations (of both threads) will be missed and so the final result in counter will be unexpected.
// if we instead use the simple blocking lock(), the result will always be the same as expected
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int counter = 0;
int N = 100000;
std::mutex mtx;

void increaseCounterNTimes() {
    for (int i=0; i<N; ++i) {
        if (mtx.try_lock()) {
            ++counter;
            mtx.unlock();
        }
    }
}

int main() {

    std::thread t1(increaseCounterNTimes);
    std::thread t2(increaseCounterNTimes);
    t1.join();
    t2.join();

    cout << "counter increased up to " << counter << endl;

    return 0;
}
//------------------

// 2. std::mutex::try_lock
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int counter = 0;
int N = 100000;
std::mutex mtx;

void increaseCounterNTimes() {
    for (int i=0; i<N; ++i) {
        if (mtx.try_lock()) {
            ++counter;
            mtx.unlock();
        }
    }
}

int main() {

    std::thread t1(increaseCounterNTimes);
    std::thread t2(increaseCounterNTimes);
    t1.join();
    t2.join();

    cout << "counter increased up to " << counter << endl;

    return 0;
}

//------------------




//------------------
// std::try_lock In C++11 Threading
// 01:09:33 - 
// 1. std::try_lock  (try locking multiple mutexes in series)
// syntax: std::try_lock(m1, m2, m3, m4,.. ,mn);
// * try_lock() can have multiple mutexes as arguments. when called, it will try to lock each one in the orders they were passed. if all locks were successful, then it will return -1. if it failed to lock one of the mutexes, it will return a 0-based index of the mutex that failed to be locked, based on the order of how that mutex was passed (e.x. mutex 3 lock failed - return 2)
// * on failure to lock any of the passed mutexes, the function will release all mutexes it has locked before the failure.
// * if a call to try_lock result in an exception, unlock is called for any locked objects before rethrowing.
//------------------

// example: we have two threads, two mutexes and two shared resources, one for each thread.
// each thread locks its own mutex, updates its resource, unlocks its mutex and then sleep for a second.
// a third thread is running in the background, constantly trying to lock both mutexes. while both first two threads are sleeping, the third thread will get to lock both mutexes and then consume the values in both resources of the two threads.
// * notice that the third thread is using try_lock while the first two threads are using lock, which blocks then from continuing. this is intended so if one of the first two threads are trying to lock its own resource, it will have to wait until the third thread will finish using its value.
// ** std::ref() is a reference wrapper and is required when passing elements by reference to it at thread initialization	
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

int X=0, Y=0;
std::mutex m1, m2;

// put calling thread to sleep for "secs" seconds
void doWorkForXSecs(int secs) { 
	std::this_thread::sleep_for(std::chrono::seconds(secs)); 
}

// the job for the first two threads. for X times, update its own resource and then sleep to allow third thread to consume the updated values
void incrementXorY(int& XorY, std::mutex& m, const char* desc) {
	for (int i=0; i<5; ++i) {
		m.lock();
		++XorY;
		cout << desc << XorY << endl;
		m.unlock();
		doWorkForXSecs(1);
	}
}

// the job of the third thread. constantly try to lock both mutexes and on success, use the values and then release the mutexes so the first two threads can continue their work.
void consumeXnY() {
	int useCount = 5;
	int XplusY = 0;
	while (1) {  // endless loop that must be broken
		int lockResult = std::try_lock(m1, m2);  // try locking both mutexes in order to use both shared resources X and Y. if the result is -1 then we successfuly locked both 
		if (lockResult == -1) { 
			if (X != 0 && Y != 0) {
				--useCount;
				XplusY += X+Y; // use the shared resources.
				X = Y = 0; // zero the resources after being used.
				cout << "XplusY " << XplusY << endl;
			}
			m1.unlock(); m2.unlock(); // unlock both mutexes! - a must.
			if (useCount == 0) break; // break the loop if we used the shared resources for the amount of times that was pre-defined.
		}
	}
}

int main() {
	
	std::thread t1(incrementXorY, std::ref(X), std::ref(m1), "X ");  
	std::thread t2(incrementXorY, std::ref(Y), std::ref(m2), "Y ");
	std::thread t3(consumeXnY);
	
	t1.join();
	t2.join();
	t3.join();
	
	return 0;
}
//------------------




//------------------
// Timed Mutex In C++ Threading
// 01:21:07 - 
// 4. std::timed_mutex::try_lock
// this mutex can block and try to lock for specified amount of time, after which it will return false since it failed to lock. if lock achieved in the alloted time it will return true.
// available methods:
// "lock", "try_lock" and "unlock" - the same as regular mutex
// "try_lock_for" - try to lock until acquired or until a duration elaped.
// "try_lock_until" - 
//------------------

// example: "try_lock_for"
// we create two threads and run the same job. the job is to try to lock for X seconds. if lock success then wait for Y seconds and release the mutex.
// we can see that if time X (time to try acquire lock) is less than time Y (time a thread wait when acquired a lock), then one thread will not be able to acquire the lock and will fail to enter.
// X=1, Y=2 -> thread 2 will fail and thread 1 will succeed.
// X=2, Y=1 -> both threads succeed
// X=1, Y=1 -> !! unexpected !!
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

int amount = 0;
int X=2, Y=1;
std::timed_mutex m;

void increment(int i) {
	if (m.try_lock_for(std::chrono::seconds(X))) {
		++amount;
		std::this_thread::sleep_for(std::chrono::seconds(Y));
		cout << "thread " << i << " entered" << endl;
		m.unlock();
	} else {
		cout << "thread " << i << " failed to enter" << endl;
	}
}

int main() {
	
	std::thread t1(increment, 1);
	std::thread t2(increment, 2);
	
	t1.join();
	t2.join();
	
	cout << amount << endl;
	return 0;
}
//------------------




//------------------
// Recursive Mutex In C++ Threading
// 01:32:51 - 
// 7. std::recursive_mutex::try_lock
// this mutex allows the same thread to lock the same mutex multiple times. this is opposed to the regular mutex where if lock is called again will cause a runtime failure.
// if thread X has locked mutex M for N times, it will HAVE TO unlock it for N times. until then, mutex M will be considered locked for all other threads and they won't be able to lock it themselves.
// the amount of recursive locks that is allowed is undefined but if reached, then it will return "std:system_error" in case we call "lock" and will return false if we call "try_lock"
// it is advised to avoid using it if not neccessary
//------------------

#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

std::recursive_mutex m1;
int buff = 0;

// Example 1: using recursion
void recursion(char c, int loopFor) {
	if (loopFor<0)
		return;
	
	m1.lock();
	cout << "thread " << c << " " << buff++ << endl;
	recursion(c, --loopFor);
	m1.unlock();
	cout << "unlock by thread " << c << endl;
}

// Example 2: using loop
void loop(char c, int loopFor) {
	for (int i=0; i<loopFor; ++i) {
		m1.lock();
		cout << "lock by thread " << c << endl;
	}
	for (int i=0; i<loopFor; ++i) {
		m1.unlock();
		cout << "unlock by thread " << c << endl;
	}
}

int main() {
	
	// Example 1: using recursion
	std::thread t1(recursion, 'A', 1000);
	std::thread t2(recursion, 'B', 1000);
	t1.join();
	t2.join();
	
	// Example 2: using loop
	std::thread t3(loop, 'C', 1000);
	std::thread t4(loop, 'D', 1000);
	t3.join();
	t4.join();
	
	return 0;
}


//------------------




//------------------
// Lock Guard In C++ Threading
// 01:53:21 - 
// syntax: "std::lock_guard<std::mutex> myLockGuard(myMutex)"
// lock_guard is a lightweight wrapper that owns a mutex in certain scope
// once created, it automatically locks the mutex.
// once goes out of scope (and thus destroyed), it automatically unlocks the mutex.
// does not allow direct unlock to the mutex it owns, and it cannot be copied.
// the example below shows that we want to unlock just before exiting the task, so instead of using regular "unlock" at the end, we can just use a lock_guard, and we can be sure it will unlock when exiting the task since it goes out of scope and thus releasing the mutex.
//------------------
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

std::mutex m1;
int buff = 0;

void task(const char* threadNum, int loopFor) {
	std::lock_guard<mutex> lg(m1); // wrap our mutex and acquire lock
	for (int i=0; i<loopFor; ++i) {
		buff++;
		cout << "thread: " << threadNum << " buffer: " << buff << endl;
	}
	// implicitly unlock the mutex at exit
}

int main() {
	std::thread t1(task, "1", 50);
	std::thread t2(task, "2", 50);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------




//------------------
// Unique Lock In C++ Threading
// 02:02:14 - 
// syntax: "std::unique_lock<std::mutex> myUniqueLock(myMutex, (optional)STRATEGY)"
// unique_lock is a class of a mutex ownership. it is also a wrapper.
// similarly 
// provides:
// 1. using multiple locking strategies:
// 2. timed locking attempts (try_lock_for & try_lock_until)
// 3. recursive locking
// 4. transfer of lock ownership (moving of the lock, NOT copying it)
// 5. condition variables.
// locking strategies:
//		TYPE			EFFECT
//		----			------
// 0. 					no strategy
// 1. defer_lock		do not acquire ownership of the mutex
// 2. try_to_lock		try to acquire ownership of the mutex without blocking
// 3. adopt_lock		assume the calling thread already have ownership on the mutex.
//------------------
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

std::mutex m1;
int buff = 0;

// e.x. 1: no strategy
void task__1(const char* threadNum, int loopFor) {
	std::unique_lock<mutex> ul(m1); // auto lock here
	for (int i=0; i<loopFor; ++i) {
		buff++;
		cout << "thread: " << threadNum << " buffer: " << buff << endl;
	}
	// implicit unlock here on unique_lock destructor
}

// e.x. 2: defer_lock
void task__2(const char* threadNum, int loopFor) {
	std::unique_lock<mutex> ul(m1, std::defer_lock); // just ownership, no lock
	ul.lock(); // manuall lock it here (lock on the owner, NOT the mutex itself!)
	for (int i=0; i<loopFor; ++i) {
		buff++;
		cout << "thread: " << threadNum << " buffer: " << buff << endl;
	}
	// implicit unlock here on unique_lock destructor
}

// e.x. 3: try_to_lock
void task__3(const char* threadNum, int loopFor) {
	std::unique_lock<mutex> ul(m1, std::try_to_lock); // try to take ownership and lock
	if (ul.owns_lock()) {
		for (int i=0; i<loopFor; ++i) {
			buff++;
			cout << "thread: " << threadNum << " buffer: " << buff << endl;
		}
	}
	// implicit unlock here on unique_lock destructor
}

// e.x. 4: adopt_lock
void task__4(const char* threadNum, int loopFor) {
	m1.lock(); // lock  manually before taking ownership (lock the mutex itself! NOT the unique_lock object
	std::unique_lock<mutex> ul(m1, std::adopt_lock); // take ownership only. assume the mutex already locked
	/*
	//the two lines above are equivalent to:
	std::unique_lock<mutex> ul(m1, std::defer_lock);
	ul.lock();
	*/
	if (ul.owns_lock()) {
		for (int i=0; i<loopFor; ++i) {
			buff++;
			cout << "thread: " << threadNum << " buffer: " << buff << endl;
		}
	}
	// implicit unlock here on unique_lock destructor
}

int main() {
	
	// e.x. 1: no strategy
	std::thread t1(task__1, "1", 50);
	std::thread t2(task__1, "2", 50);
	t1.join();
	t2.join();
		
	// e.x. 2: defer_lock
	buff = 0;
	std::thread t3(task__2, "3", 50);
	std::thread t4(task__2, "4", 50);
	t3.join();
	t4.join();
		
	// e.x. 3: try_to_lock
	buff = 0;
	std::thread t5(task__3, "5", 500);
	std::thread t6(task__3, "6", 500);
	t5.join();
	t6.join();
		
	// e.x. 4: adopt_lock
	buff = 0;
	std::thread t7(task__4, "7", 50);
	std::thread t8(task__4, "8", 50);
	t7.join();
	t8.join();
	
	return 0;
}
//------------------




//------------------
// Condition Variable In C++ Threading
// 02:13:49 - 
// allows notifying other threads, effectively synchronizing them
// allows a thread to wait for a condition to occur
// most common use-case is the "producer<->consumer" paradygm.
// threads are notified using "notify_one()" and "notify_all()"
// it requires a mutex object in order to work
// A thread wishing to wait for a condition to occur will follow these steps:
// 1. aquire the mutex lock using "std::unique_lock<std::mutex> ul(m)"
// 2. call "wait", "wait_for" or "wait_until". this wait operations atomically release the mutex and suspends the execution of the current thread. 
//    we pass the CONDITION PREDICATE as a parameter to the wait call.
//    syntax: "myConditionVariable.Wait(myMutex, CONDITION_PREDICATE);"
// 3. once the condition defined in the condition variable is met, the thread resumes and the mutex is atomically re-acquired. it is recommended for that thread to manually check for that condition itself, to avoid spurious wakes.
//------------------

//the example below shows a simple case where one thread is trying to withdraw money from an account, and another thread is trying to add money to the account. the withdraw thread starts first and the main thread waits some time and only then starts the second thread which adds money. money cannot be withdrawed if the balance is insufficient so the withdraw thread waits before attempting its action, and waits for a notification from the add money thread before it attempts to withdraw
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
using namespace std;

std::condition_variable cv;
std::mutex m;
long balance = 0;

void addMoney(int amount) {
	cout << "attempting to add " << amount << " to balance..." << endl;
	std:lock_guard<mutex> lg(m);
	balance += amount;
	cout << "amount added to current balance: " << balance << endl;
	cv.notify_one();  // using "notify_one" since only one thread waits.
}

void withdrawMoney(int amount) {
	cout << "attempting to withdraw " << amount << " from balance..." << endl;
	std::unique_lock<mutex> ul(m);
	cv.wait(ul,
	// the CONDITION PREDICATE. while false it will keep waiting 
	[] { return (balance != 0) ? true : false; } 
	);
	if (balance >= amount) {
		balance -= amount;
		cout << "amount deducted: " << amount << endl;
	} else {
		cout << "amount " << amount << " cannot be deducted, balance of " << balance << " is insufficient." << endl;
	}
	cout << "current balance is: " << balance << endl;
}

int main() {
	
	std::thread t1(withdrawMoney, 450);
	std::this_thread::sleep_for(std::chrono::seconds(2));
	std::thread t2(addMoney, 500);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------




//------------------
// DeadLock With Example In C++
// 02:28:14 - 
// A situation where two threads are waiting for each other to release a resource that they require in order to continue.
//------------------

// the example below shows a very simple deadlock situation
// we have two threads and two mutexes. each thread require both mutexes to be locked in order to execute its critical section and then release the mutexes.
// thread 1 locks mutex 1 then wait for X microseconds and then it locks mutex 2
// thread 2 locks mutex 2 then wait for X microseconds and then it locks mutex 1
// the problem occurs if
// - thread 1 locks mutex 1 and before locking mutex 2, thread 2 locks mutex 2
//    OR (the opposite)
// - thread 2 locks mutex 2 and before locking mutex 1, thread 1 locks mutex 1
// the result is that thread 1 is waiting for mutex 2 to be released by thread 2 & thread 2 is waiting for mutex 1 to be released by thread 1.
// Note that we cannot predict if and when this will happen but it CAN happen.
// to force it to happen, we insert a delay for each thread, after it locks its own mutex (thread 1 locks mutex 1 and thread 2 locks mutex 2). if the delay is large enough then a deadlock is sure to happen every time. 
// a 1 second delay is sure to make it happen every time
// * a simple solution is to just flip the lock order in one of the thread tasks so it will match the order of the second one.
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

std::mutex m1;
std::mutex m2;

int lockingDelayus = 1000;

void thread1() {
	cout << "enter thread 1" << endl;
	m1.lock();
	cout << "mutex 1 locked by thread 1" << endl;
	std::this_thread::sleep_for(std::chrono::microseconds(lockingDelayus));
	m2.lock();
	cout << "critical section in thread 1" << endl;
	m1.unlock();
	m2.unlock();
}
void thread2() {
	cout << "enter thread 2" << endl;
	m2.lock();
	cout << "mutex 2 locked by thread 2" << endl;
	std::this_thread::sleep_for(std::chrono::microseconds(lockingDelayus));
	m1.lock();
	cout << "critical section in thread 2" << endl;
	m2.unlock();
	m1.unlock();
}

int main() {
	
	std::thread t1(thread1);
	std::thread t2(thread2);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------




//------------------
// Synchronisation (demonstrated with threads, but applies to processes sync also)
// 02:36:57 - 
// this demonstrates the simple concept of critical section, which is a set of commands that must be executed by one thread at a time.
// a critical section MUST contain a WRITE command. reading a value is not considered a critical section (if nothing is returned from the task, which is common). this means that we must synchronize commands that write on shared variables.
//------------------
// the example shows two threads trying to read a shared variable. without proper sync method, and although very rare, a situation might happen that both threads will arrive at the first line of the task at the same time and both will read the balance as 0 and thus the final balance will not be 300.
// use the "USE_SYNC" to add or remove the sync code to see the result.
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

// USE_SYNC == 0  -> no sync - will produce errors
// USE_SYNC == 1  -> with sync - no errors will be produced
#define USE_SYNC 0

#if USE_SYNC
std::mutex m;
#endif

typedef long long ll;
ll bankBalance = 0;

void addMoney(ll val) {
#if USE_SYNC
	m.lock();
#endif
	bankBalance+=val;
#if USE_SYNC
	m.unlock();
#endif
}

int main() {
	
	for (int i=0; i<10000; ++i) {
	    bankBalance = 0;
		std::thread t1(addMoney, 100);
		std::thread t2(addMoney, 200);
		t1.join();
		t2.join();
	    if (bankBalance < 300)
	        cout << "iteration " << i << ": ERROR!. balance: " << bankBalance << endl;
	}
	return 0;
}
//------------------




//------------------
// std::lock In C++11
// 02:50:46 - 
// syntax: std::lock(m1, m2, m3, ..., mn);
// a static function that is used to lock multiple mutex instances at the same time with one call.
// the lock attempts are done in iterations where when an iteration fails to lock all mutexes, the function unlocks all mutexes that were successfully locked, and then starts a new lock attempt iteration
// within each successive iteration the mutexes are re-arrainged in such a way that mutexes that failed to get locked in previous iteration will be attempted to get locked FIRST.
// Notes:
// 1. the process of locking all passed mutexes uses a sequence of calls to "lock", "try_lock" and "unlock" on each mutex.
// 2. the ORDER of locking is UNKNOWN. the function will try to lock all given mutexes in ANY order, while ensuring that there's no dead-lock
// 3. this function is blocking, meaning the caller will wait indefinetly until lock is finished.
//
// Case examples:
// --------------
//
// 1. --> No dead-lock 
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2);			std::lock(m1,m2);
//
// 2. --> No dead-lock 
//        one of the threads will have multiple iterations
//        * in this case, if we lock each mutex on its own, we WILL have a dead-lock
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2);			std::lock(m2,m1);
//
// 3. --> No dead-lock 
//        thread 2 will lock m3&m4 first, so thread 1 will release m1 and m2 and will have multiple iterations
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2,m3,m4);		std::lock(m3,m4);
// 								std::lock(m1,m2);
//
// 4. --> A dead-lock ooccurs here 
//        when a "lock" call fails, it can only unlock the mutexes it got passed in. thread 1 locks m1&m2, thread 2 locks m3&m4, and at this point, they moved on to the next "lock" call. the previously locked mutexes cannot be freed now because they were locked by another lock call. this is certatain to result a dead-lock.
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2);			std::lock(m3,m4);
// 	std::lock(m3,m4);			std::lock(m1,m2);
//
//------------------
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

std::mutex m1, m2, m3, m4;

void simulateWork() { std::this_thread::sleep_for(std::chrono::milliseconds(10)); }

void case1_t1Task() {
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock();
}
void case1_t2Task() {
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock();
}

void case2_t1Task() {
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock();
}
void case2_t2Task() {
	std::lock(m2,m1);
	simulateWork();
	m1.unlock(); m2.unlock();
}

void case3_t1Task() {
	std::lock(m1,m2,m3,m4);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}
void case3_t2Task() {
	std::lock(m3,m4);
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}

void case4_t1Task() {
	std::lock(m1,m2);
	std::lock(m3,m4);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}
void case4_t2Task() {
	std::lock(m3,m4);
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}

int main() {
	
	// case1
	for (int i=0; i<100; i++) {
		std::thread t1(case1_t1Task); std::thread t2(case1_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 1: " << "finished" << endl;
	
	// case2
	for (int i=0; i<100; i++) {
		std::thread t1(case2_t1Task); std::thread t2(case2_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 2: " << "finished" << endl;
	
	// case3
	for (int i=0; i<100; i++) {
		std::thread t1(case3_t1Task); std::thread t2(case3_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 3: " << "finished" << endl;
	
	// case4
	for (int i=0; i<100; i++) {
		std::thread t1(case4_t1Task); 
		simulateWork();  // insert some delay to allow t1 to lock all mutexes. if this delay is removed, a dead-lock will occur
		std::thread t2(case4_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 4: " << "finished" << endl;
	
	return 0;
}
//------------------




//------------------
// std::promise And std::future In C++ Threading and why to use them?
// 03:10:02 - 
// promise is used to set values or throw exceptions
// future is used to get data from a promise, check for avaiable data, and wait for the promise to provide data.
// the promise defines the data that it suppose to provide.
// the promise is passed as an argument to the thread job func with "std::move(myPromise)", and is received in the func signature with the syntax "std::promise<myDataType>&& myPromiseParameter"
// when the promise have the data, it signals the future with "myPromise.set_value(myValue)" method.
// the future object is provided by the promise object
// we use the future to wait for the promise value by using "myFuture.get()" method.
// as recommended. we join the thread before main is finished, EVEN though we know for sure the thread has finished!
//------------------
#include <iostream>
#include <thread>
#include <chrono>
#include <algorithm>
#include <future>
using namespace std;
using namespace std::chrono;

typedef long int ull;

void findOdd(std::promise<ull>&& oddSumPromise, ull start, ull end) {
	ull oddSum = 0;
	for (ull i=start; i<=end; ++i) {
		if (i & 1) {
			oddSum += i;
		}
	}
	oddSumPromise.set_value(oddSum);
}

int main() {
	
	ull start=0, end = 1900000000;
	
	std::promise<ull> oddSum;
	std::future<ull> oddFuture = oddSum.get_future();
	
	cout << "creating and starting a thread" << endl;
	std::thread t(findOdd, std::move(oddSum), start, end);
	cout << "waiting for the promise to be provided" << endl;
	
	cout << "oddSum: " << oddFuture.get() << endl;
	
	cout << "job completed" << endl;
	t.join();
	return 0;
}
//------------------




//------------------
// std::async In C++ Create A Task
// 03:18:20 - 
// executes a function asynchronically (can be within a new thread but not must be), and at task end it returns an "std::future" object that holds the result.
// it encapsulates the promise and future mechanism and simplifies it.
//
// launch policies:
// 1. std::launch::async
// 		-> start upon creation of the future object.
// 		-> the task will be executed in a new thread
// 2. std::launch::deferred
// 		-> start upon calling "get" function on the future object.
// 		-> the task will be executed on the main thread (no new thread)
// 3. std::launch::async | std::launch::deferred	
//		-> either or, let the computer decide
//
// How it works internally:
// 1. creates a new dedicated thread OR picks a thread from an internal thread-pool, and creates an "std::promise" object to control the sync.
// 2. it passes the "promise" object to the task function and returns the "future" object that is created from the promise.
// 3. when the task function exits, the value is set in the future object and the return value of that function will be contained in that object.
// Notes: 
// the task function can also be a functor or a lambda function.
// this is a very clean way to run a regular function in a thread - no need to change anything in the function, meaning we decoupled the threading mechanism from the logic of the function.
//------------------
#include <iostream>
#include <thread>
#include <chrono>
#include <algorithm>
#include <future>

using namespace std;
using namespace std::chrono;

typedef long int ull;

ull findOdd(ull start, ull end) {
	
	cout << "Task thread ID = " << std::this_thread::get_id() << endl;
	
	ull oddSum = 0;
	for (ull i=start; i<=end; ++i) {
		if (i&1) {
			oddSum += i;
		}
	}
	return oddSum;
}

int main() {
	
	ull start = 0, end = 1900000000;
	
	cout << "Main thread ID = " << std::this_thread::get_id() << endl;
	
	cout << "\nExample: policy = async" << endl;
	std::future<ull> oddSumResAsync = std::async(std::launch::async, findOdd, start, end);
	cout << "A thread starts upon creation. \n lets wait for a while and only then call \"get\" on the future object. the result will be immediate" << endl;
	cout << "main thread sleep for 5 seconds.." << endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(5000));
	cout << "sleep finished" << endl;
	cout << "waiting for the result.." << endl;
	cout << "oddSum: " << oddSumResAsync.get() << endl;
	cout << "complete." << endl;
	
	cout << "\nExample: policy = deferred" << endl;
	std::future<ull> oddSumResDeferred = std::async(std::launch::deferred, findOdd, start, end);
	cout << "The task starts when calling \"get\" on the future object. note that it executes on the main thread!. \n lets wait for a while and only then call \"get\" on the future object. the result will take some time" << endl;
	cout << "main thread sleep for 5 seconds.." << endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(5000));
	cout << "sleep finished" << endl;
	cout << "waiting for the result.." << endl;
	cout << "oddSum: " << oddSumResDeferred.get() << endl;
	cout << "complete." << endl;
	
	return 0;
}
//------------------




//------------------
// Producer And Consumer Problem In C++ With Code Implementation
// 03:29:08 - 
// This is a know problem in thread oriented programming
// A producer produces data that is saved into a limited buffer.
// A consumer consumes data within the buffer when available. 
// Both producer and consumer are MODIFYING (writing) the buffer. producer inserts data while consumer removes data, so to synchronizes this mechanism we must use a mutex. 
// There can be multiple producers as well as multiple consumers. We'll focus on the simple case of one producer and one consumer.
// To implement this we need a mutex and a condition variable to add further condition on when the consumer should consume (the buffer is not empty), and when the producer should produce data into the buffer (the buffer is not full
// when producer produce it notifies the consumer. when the consumer consume it notifies the producer.
// the "problem" is that the order of the sequence of both producer and consumer taking over the buffer is unexpected. if we consider limit the producer (add a small delay between each production cycle), it is an inefficient use of the system capabilities. 
//------------------

// this example shows the simple case described above. 
// The PRODUCER gets a value from which it produces values from that value until 0, and then exits. 
// it first try to lock the mutex using a unique_lock object and then waits for a notification from the consumer using the condition variable. 
// once a notification arrives, the condition "buffer is not full" is checked  and if met it tries to lock the mutex. then it pushes the value to the buffer, unlocks the mutex and finally notify the consumer that it can have his turn
// The CONSUMER enters an infinite loop where on each iteration it waits for a notification from the producer using the same mutex and condition variable instances, but with the "buffer not empty" condition.
// upon notification it then locks the mutex and dequeue the last value pushed (FILO), unlocks the mutex and finally notifies the producer.
// NOTE - on each execution of the code, the order of producing and consuming is unexpected!. 
// if we make the producer sleep a little bit in between production cycles, the order is then expected but is inefficient

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <deque>
using namespace std;

std::mutex mu;
std::condition_variable cv;
deque<int> buffer;  // a queue-like buffer. basically circular
const unsigned int maxBuffSize = 50;

void producer_task(int value) {
	while (value) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() < maxBuffSize;
		} );
		buffer.push_back(value);
		cout << "Produced value: " << value << endl;
		--value;
		ul.unlock();
		cv.notify_one();
		// limit the producer to allow the consumer to get values before the buffer is full
		//std::this_thread::sleep_for(std::chrono::milliseconds(1));  
	}
}

void consumer_task() {
	while (1) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() > 0;
		} );
		int value = buffer.back();
		buffer.pop_back();
		cout << "Consumed value: " << value << endl;
		ul.unlock();
		cv.notify_one();
	}
}

int main() {
	std::thread producerThread(producer_task, 100);
	std::thread consumerThread(consumer_task);
	producerThread.join();
	consumerThread.join();
	
	return 0;
}


// this example shows the case where we have one producer and two consumers.
// the difference is we create two consumer threads with the same task, and also when the producer notifies, it notifies all, not one, though it seems to not have a big difference with the sequence. 
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <deque>
using namespace std;

std::mutex mu;
std::condition_variable cv;
deque<int> buffer;  // a queue-like buffer. basically circular
const unsigned int maxBuffSize = 50;

void producer_task(int value) {
	while (value) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() < maxBuffSize;
		} );
		buffer.push_back(value);
		cout << "Produced value: " << value << endl;
		--value;
		ul.unlock();
		cv.notify_all();
		// limit the producer to allow the consumer to get values before the buffer is full
		//std::this_thread::sleep_for(std::chrono::milliseconds(1));  
	}
}

void consumer_task(int threadID) {
	while (1) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() > 0;
		} );
		int value = buffer.back();
		buffer.pop_back();
		cout << "Consumer " << threadID << " Consumed value: " << value << endl;
		ul.unlock();
		cv.notify_one();
	}
}

int main() {
	std::thread producerThread(producer_task, 1000);
	std::thread consumerThread1(consumer_task, 1);
	std::thread consumerThread2(consumer_task, 2);
	producerThread.join();
	consumerThread1.join();
	consumerThread2.join();
	
	return 0;
}
//------------------





//------------------
// Sleep VS Wait In Threading, when to use what?
// 03:44:44 - 
// "Sleep": a notification from a thread to the OS to dismiss its execution timeslice, fora specified time (or more time). while sleeping, the OS doesn't try to scheduale more execution time for that thread, until specified sleep time elapses
// -> sleep will KEEP THE LOCK while sleeping. - blocking
// -> sleep is a thread function.
// "Wait": a notification from a thread to the OS to dismiss its execution timeslice until other threads notify the thread (through notify_one or notify_all), at which point the thread can test a specified condition. while waiting, the OS doesn't try to scheduale more execution time for that thread, until the thread is being notified through a shared sync object (or some wakeup scenarios occur)
// -> wait RELEASES THE LOCK and then waits - non-blocking
// -> wait is applied to a condition variable which puts the thread into wait state.
//------------------
#include <iostream>

int main() {
	return 0;
}
//------------------







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
A complete tutorial playlist
https://www.youtube.com/watch?v=18c3MTX0PK0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

How the C++ Compiler Works
------
pre-process - evaluate all constants and preprocess phrases
tokenizing and parsing - creating an "abstract syntax tree"
- convert all the code to constant data or instructions
from "abstract syntax tree" it creates actual machine code
generate .obj file for each source file - translation units
cpp doesnt care about files, it cares about translation units
programmer is responsiable to tell what the file type is and how to treat it (giving a .c/.h file will result the compiler handling ti like an old c file - it a convention)
a translation unit will result an obj file
#include <iostream> creates a huge overhead. iostream gives us the cin/cout and the << >> print operators, among other things.
#include [FILE] - paste the included file content in place of the statement. very simple
the .i files are generated when include statements are in place. it contains the intermediate files where the includes were applied.
in project properties - preprocess to a file, it will create the .i files and also will NOT compile the program (also wont create obj files)
#if preprocessor statements
when including <iostream> the resulting .i file gets huge!
.obj files are binary data.
to make a readable obj file (in assembly) - project properties - output file - assembler output - change it from No listing to assembly only listing. this will create an .asm file
project properties - select "Debug" configuration - C/C++ - optimization - set to maximize speed. this will give an error so then project properties - C/C++ - Code Generation - set basic runtime checks to "default". this will result in a really small footprint asm file.
function signature in .asm files. its a uniqe code assigned to each func. the linker will use it to find symbols in different files.
-------

How the C++ Linker Works
-------
find where each symbol is and link those together. obj files are in their own scope and cannot see eachother.
even if we have a single source file, then entry point "main" needs the linker to tell use where it is.
in C++, when we press the compile button, only compilation will occur! the linking process will not happen. only if we build the project then the linking will happen. to show this we can ommit the "main" func from our project. in this case we'll see that compiling will work but building (compiling and linking) will NOT work. (only app project (executable and not library prject) will produce this linking error.
compile error code that starts will the letter "C" is a compiler error. LNK is a linker error.
a declaration of a func can be set to tell the linker to find a resource (a func in this case) with a specific signature.
if a singature is given but there's no actual definition of that func anywhere, then we get a linking error. Note that this will only happen if we actually try to call that function. if no one calls it, we get 0 linker error. However we get a linker error if we allow the caller function to call this unresolved func, but we do not call the calling function anywhere. the compiler will not drop the caller function, even if it is not called anywhere, and so the unresolved call will remain. This is because this caller function might be used outside of our source file and so it is not dropped from compilation.
to make a function available only in its own source file, we use the "static" keyword in the func declaration. this will dismiss the linking error mentioned above.
Duplicated objects with the same signature/name will result a compile error. for example if we define the same function in two separate src files, and call it from one file, the compilying will PASS! but the linking will fail. linker cannot decide which definition of the func it should like our call to.
"inline" keyword for functions - replace call will content of func, similar to #define macros
-------

Variables in C++
-------
naming memory data to allow referencing.
data types. C++ is loose with types. the really diference is only the byte count of the data.
append 'f' to literal floating point value to make it float and not double.
sizeof operator
-------

Functions in C++
-------
refactoring to functions.
calling a function required creating a call parameter frame and also a return address, all pushed into the stack.
compiler can inline a function.
main is a special function is allowed to not specify to return a value. it will return 0 automatically if not specified
-------

C++ Header Files
-------
a common place to store declarations. no definitions.
#pragma once - allow including a file only once in a single translation unit, to avoid multiple definitions of funcs/vars as a result of a multiple includes
#ifndef X #define X ... #endif - this pattern can replace the pragma once.
we use pragma once because is way more cleaner. in C i used the ifndef a lot. use pragma once!
include "" and include <> - 
 "" - we can give a relative path to the included file
 <> - allow the complier to search for the file
 
.h extension for header files is used in include statements of C headers
in C++, we do not all the .h to the referenced file. (ex <iostream>)
--------

How to DEBUG C++ in VISUAL STUDIO
--------TODO

CONDITIONS and BRANCHES in C++ (if statements)
--------
evaluation and branching
go to dissassembly
--------


BEST Visual Studio Setup for C++ Projects!
--------TODO

Loops in C++ (for loops, while loops)
--------TODO

Control Flow in C++ (continue, break, return)
--------TODO

POINTERS in C++
--------
everything is memory.
a pointer is an integer that stores an address to the memory. it is also a variable and it also has its own address in memory, which btw can be referenced by another pointer.
void pointer - it is a typeless pointer. this definition only has meaning in the source. its for our eyes.
 - void* myptr;
null pointer - set a pointer value to 0 - it is not a valid pointer because 0 is not a valid address. 0 means NULL.
c++ keyword - "nullptr" a definition for a NULL pointer introduced C++ v11.0
 void* myptr = nullptr;
we can point to an existing var with a new pointer. to get the address of a var we put an ampercent next to it.
 - int x = 8;
 - void* myptr = &x;
use the "memory" view to see the value in memory at specific addresses. note that memory is little endian so if int is 4 bytes, it will be stored in reverse order
changing "void*" to "int*" does NOT actually change anything.
dereferencing a pointer - this is where we get the value that the pointer is pointing to.
 - int x = 8;
 - void* myptr = &x;
 - *myptr // dereferencing.
to set a value to a variable pointed by a pointer, we need to set the correct type to the pointer, then use dereference to set the value.
 - int x = 8;
 - int* myptr = &x;
 - *myptr = 10 // dereferencing - now var x will have the value 10
a pointer is not actually pointing to a BLOCK of memory, but only a single POINT in memory, even though we gave it a size.
pointer is pointing to a memory on the STACK
memory allocation - when using the "new" keyword, we allocate a memory on the HEAP. the new will return the address of the newly allocated buffer.
 - char* buffer = new char[8];
 - memset(buffer, 10, 8); //now we can use funcs like memset. set all values in buffer to 10.
we can use delete keyword to de-allocate the memory.
 - delete[] buffer;
pointers can point to other pointers, in such an endless chain of pointing
 - char* buffer = new char[8];
 - memset(buffer, 10, 8);
 - char** ptr = &buffer; // a pointer to a pointer.
--------

REFERENCES in C++
--------
pointers in disguise. sugar over pointers.
references to an existing var. convenient way to reference.
does not have a variable of its own. does not technically take memory.
cannot be empty like pointers does. it must refer to an already existing var. - cannot equal to NULL.
ex
 - int a = 5;
 - int& ref = a; // & does not mean here "the address of" like in pointers.
				 // its just a part of the type name/keyword.
ref is not a variable here. it is called an "alias"
 - ref = 2; // if we print ref we'll see the value 2.
i can be used to easly pass a variable BY ITS REFERENCE 
ex.
 this is how affecting a variable by ref is done with POINTERS
  void Inc(int* value)
  {
	(*value)++;
  }
  int main()
  {
	int a = 5;
	Inc(&a);
	Print(a);
  }
 here in main we have a local var "a". the func "Inc" takes a pointer to a var, dereference it, then increment the value that is in that memory location. returns nothing back. the syntax is not very nice because we have a lot of * and & its harder to read.
  
 this is how affecting a variable by ref is done with REFERENCE
  void Inc(int& value)
  {
	value++;
  }
  int main()
  {
	int a = 5;
	Inc(a);
	Print(a);
  }
 here we replaced the * with & on the "Inc" func sig, similar to this line "int& ref = a;" we did above. then we removed the dereferencing in the increment statement.
 finally we removed the & from the call to the func "Inc". This looks way cleaner.
in the example above, the compiler will do exactly the same!

once refered to a certain variable, it cannot be changed to other variables!
 ex
  int a = 5;
  int b = 3;
  int& ref = a;
  ref = b; //this will not make "ref" refer to variable "b" now, instead it will simply set the variable "a" value to the value in variable "b"
with pointers we CAN do this like the following
 ex
  int a = 5;
  int b = 3;
  int* ref = &a; // create the pointer and point it to "a"
  *ref = 2; // set value in "a" to be 2, by dereferencing the pointer
  ref = &b; // point the pointer to "b" now
  *ref = 1; // set value in "b" to be 1, by dereferencing the pointer
--------


CLASSES in C++
--------
Need a ; at the end of a class definition
 -	class Foo {
 -	
 -	};
To public a class variable, we write "public:" and what is below this line will be public
 -	class Foo {
 -	public:
 -		int x, y;
 -	};
Usage, as in C#. i.e Foo f; f.x = 3;
In this example, "f" is and INSTANCE of type CLASS Foo. 
the name of the var "f" is pointing to the location in memory, like pointers.
we can send it to a func by REF.  
 e.x  
 void Bar(Foo& f);   
 main {
	Foo aFoo;
	Bar(aFoo);
 }
The real OOP way to do this is called methods which are functions that is contained within a classs
 -	class Foo {
 -	public:
 -		int x, y;
 -		void Bar() { ... }
 -	};
Then to call the same func we do in main  aFoo.Bar();
--------


CLASSES vs STRUCTS in C++
--------
the real only difference between them is that A struct is by default all public whereas a class is private by default. we can add the keyword "public:" or "private:" to any of the two to change that
e.x
- class Foo {
- public:
- 	int x;	
- }
- struct Foo {
- private:
- 	int x;	
- }

When to use each:
 structs whenever possible, faster, when just manipulating data, such as a Vec2 or something similar. this Vec2 should stay small in definition because it only represent the data of a vector.
 classes when the functionality is complicated to describe in a single unit struct
However, a struct can conain functions like classes!!
Structs should NOT have inheritance relations
--------


--------
How to Write a C++ Class
--------
e.x. Log class


class Log 
{
public:
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;
private:
	int m_LogLevel = LogLevelInfo;
public:
	void SetLevel(int level)
	{
		m_LogLevel= level;
	}
	
	void Error(const char* message)
	{
		std::cout << "[Error]: " << message << std::endl;
	}
	void Warn(const char* message)
	{
		std::cout << "[Warning]: " << message << std::endl;
	}
	void Info(const char* message)
	{
		std::cout << "[Info]: " << message << std::endl;
	}
 
};

int main()
{
	Log log;
	log.SetLevel(log.LogLevelWarning);  //access to const via the log instance
	log.Warn("Hello");
	std:cin.get();
}

--------

Static in C++
--------
static int s_Var = 5; 
A static Var means that it is only going to be linked inside its own translation unit. the linker is not going to look outside of the definition of the var

to view a variable outside of its translation unit, we remove the "static" keyword, then on the other file that wishes to see that var, we delare it a again only this time we add the "extern" keyword
This is called "External Linking"

file A
int s_Var = 5
file B
extern int s_Var; 
int main() {sVar = 6;} 

if we add "static" to s_Var in file A we'll get a compiling error

file A
static int s_Var = 5
file B
extern int s_Var; 
int main() {sVar = 6;} 

The same is true for functions.

one should mark a variable "static" as much as possible, if this variable is not needed at other translation units

--------

Static for Classes and Structs in C++
--------
a static variable in a class is going to exist only once across all instances of that class.
a static method can only be called "statically" and this method cannot accesss the non static elements of the class

Scope! 

struct Entity 
{
	static int x, y;
	
	void Print()
	{
		std::cout << x << "," << y << std::endl
	}
};
// we need these declarations to make the statics in the struct "Entity" visible via going throught the instance identifier and not the struct identifier.
// "x" is declared in the scope of the class "Entity". it is a static variable that belongs to the scope of the class Entity 
int Entity::x;  
int Entity::y;

int main()
{
	Entity e; 
	e.x = 1; e.y = 2;
	Entity e1; 
	e1.x = 5; e1.y = 6;
	
	// we can do instead. we can also ommit the creation of the instances!
	//Entity::x = 1; Entity::y = 2;
	//
	
	e.print(); e1.print();
	
	std::cin.get();
}

static methods can only access other static elements.
to access a static method we can use the "scope" mechanism
i.e. 
struct Entity 
{
 ..
 static void Print()
 ..
}
int main()
{
	Entity::Print();
}
--------


Local Static in C++
--------
it is only valid in a local scope - a block {}
variables generation consideration:
 scope of var
 lifetime of var 
a local static is a variable that exists through the whole life time of the program but its scope is only in the block that it is defined 

local var in a function will initialize only once, and its value is going to be kept whenever the func is called
void foo(){
	static int i = 0;
	print(i);
}
main() { foo(); foo(); foo(); }

output
1
2
3

its as if we declare the var outside the func
int i = 0;
void foo(){
	print(i);
}
but in this case, ANYONE CAN CHANGE THE VALUE OF THAT VAR, outside of the func foo

A singlton is a good way to ilustrate the usability of this concept

class Singleton{
public:
	static Singleton& Get(){   //remember the & means we will get a returned by ref
		static Singleton instance;
		return instance;
	}
};

--------


ENUMS in C++
--------
a set of values. a way to give a name to a value.
enum Foo{
	A, B, C  // in this case, the names get an iterated value, starting with 0, so A=0,B=1,..
};
main(){
	Foo f1 = A;// ok
	Foo f2 = 3;// ok
	Foo f3 = 5;// compile error
	if (f2 == B)
	if (f2 > A)
}
we can specify the value range of the enum
enum Foo : unsigned char {
	A, B, C  // we dont have so many different values so we can be satisfied with an unsigned char
	// also it has to be an integer
}
we can use an enum with the example of the log, making log level into an enum and use it
--------


Constructors in C++
--------
a func that is called whenever we construct an object. it is an actual init func.
a default constructor is given to all classes in case a custom constructer is not defined
class Foo {
private:
	float X, Y;
	Foo() { } // the constructor. IT WILL NOT ACTUALLY DEFALUT ANY VARIABLE VALUES. we must do that ourselves "Foo() { X = Y = 0.0f; } ". we must init all primitives
public:
	void print() { std::cout << X << "," << Y << std::endl; }
}
main(){
	Foo f; // the constructor is called here (apparently without the "new Foo();" thing 
	std::cout << f.X << "," << f.Y << std::endl
	f.print();
}

constructor with parameters
private:
	float X, Y;
	Foo(float x, float y) { X = x; Y = y; } //

we can hide the default constructor so that instances of that class cannot be initiated.
this is done by overriding the default constructor to be private. 
this is good for a static only class like a Log class

class Foo {
private:
	Foo() {}
}
main(){
	Foo f; // this gives an error
}
--------



Destructors in C++
--------
a destructor is a method. it will be called whenever we dewstroy an object.
THE DESTRUCTOR REFERS TO BOTH STACK AND HEAP ALLOCATIONS
 objects created in heap (with the new keyword) will be destroyed when we call "delete" on them
 on the stack (ClassName InstanceName;) whenever the scope ends, the object will be destroyed.

class Foo{
public:
	Foo() { Print(CONSTRUCTED) } // constructor
	~Foo() { Print(DESTROYED) } // destructor 
	void Print() { .. print .. }
};
void Func(){
	Foo f;
	f.Print();
}
main(){
	Func(); // after this call we see that both constructor and destructor will be called
}
we can call it manually. not really used feature
void Func(){
	Foo f;
	f.~Foo();
}



Inheritance in C++
--------
class Foo {
.....
};
class Bar : public Foo
...everything that Foo has...
.....
};
--------


Virtual Functions in C++
--------

Polymorphism
Dynamic dispatch
V table
runtime function map in real time

class Foo{
public:
	std::string GetName() { return "AFoo"; } 
};
class Bar : public Foo {
private:
	std::string m_Name;
public:
	Bar(const std::string& name)
		: m_Name(name); // member initializer list in a constructor. nice way to fill member m_Name with name;
		
	std::string GetName() { return m_Name; }
};
void PrintFoo(Foo* p_foo){
	std::out << f->GetName() << std::endl;  
	// the function can get all "Foo" objects but cannot know if a the "Foo" that passed is actual a "Bar"
	// since f is a POINTER to the instance, we use -> to access the members
	
}
main() {
	Foo* f = new Foo();
	PrintFoo(f);
	
	Bar* b = new Bar("ABar");
	PrintFoo(b);
}

the program will print 
	AFoo
	AFoo
because of polymorphism, the func PrintFoo cannot know if the Foo that is passed is actual a Bar.
to fix this we simply add the keyword "virtual" to the declaration of the func "GetName" in Foo
This will allow it to be overrided and the PrintFoo func will work correctly

class Foo{
public:
	virtual std::string GetName() { return "AFoo"; } 
};

not required, however we can also write "override" on the "GetName" func on Bar
class Bar : public Foo {
...	
	std::string GetName() override { return m_Name; }
};

--------



--------
Interfaces in C++ (Pure Virtual Functions)
its like an abstract method or an interface on langs such as java/C#
defines a method in a base class that does not have an implementation, and then force inheriting classes to implement it.
interface is actually a list of methods that are ALL with no implementation.
we cannot instantiate an interface because it is not a class.

class Foo{
public:
	std::string GetName() = 0; // we removed the implementation. virtual keyword stays.
};
class Bar : public Foo {
private:
	std::string m_Name;
public:
	Bar(const std::string& name)
		: m_Name(name); // member initializer list in a constructor. nice way to fill member m_Name with name;
		
	std::string GetName() { return m_Name; } // if we remove this impl' we wont be able to instantiate classes of this type
};

main() {
	Foo* f = new Foo(); // this will trow error - we can no longer instantiate this class because it is fully virtual. we can replace it with Foo* f = new Bar("ABar");
	PrintFoo(f);
	
	Bar* b = new Bar("ABar");
	PrintFoo(b);
}


We can use pure abstract classes which ARE INTERFACES, to make a super class that both Foo and Bar will inherite. Foo and Bar will both implement it.

class printable {
public:
	virtual std::string GetClassName() = 0;
};
class Foo : public printable {
public:
	std::string GetClassName() override { return "AFoo"; }
};
class Bar : public Foo {
public:
	std::string GetClassName() override { return "ABar"; }
};

void PrintPrintable(Printable* obj){
	std:out << obj->GetClassName() << std:endl;
}
main(){
	Foo* f = new Foo();
	Bar* b = new Bar();
	
	PrintPrintable(f);
	PrintPrintable(b);
}

--------


Visibility in C++
--------
public  // all can see
private  // only owner can see  
protected  // only owner and inheriting classes can see 
**friend**  // can relate two elemnts across two separate irrelatable classes.
--------


Arrays in C++
--------
int example[5]; // example is actually a pointer
example[2] = 3;
print(example[2]); //will print the value 3
print(example); //will print the pointer value and not the variable
example[6]; // errror - memory access violation

for (int i = 0; i < 5; i++)
	example[i] = 2;
	
int* ptr = example;
*(ptr + 2) = 5; // this is the same as "example[2] = 5;"
//the arithmetics here will treat ptr with its size of int which is 4.
//we can cast the pointer to a byte pointerand then we need to modify the arithmetics
*((char*)ptr + 4*2)
//also, to  finally set the integere value, we must cast it back to an int pointer
*(int*)((char*)ptr + 4*2) = 5; // this is exactly as above

//creating arrays on the heap
int* arr = new int[5]; // this is the same array but its created on the heap
//arr can now be used exactly the same
arr[2] = 5;
//since this is on the heap, we must destroy it after. since its an array, we use "delete[]"
delete[] arr;

//creating an array on the heap requires more overhead. ex we use a pointer to define and access so it adds jumps in memory, as opposed to creating them on the stack which requires no jumps in memory.
// for this reason we should create arrays on the stack as much as possible 
int example[5]; 

//its not easy to keep track of the size of the heap array shown above. its is compiler dependent and not clear where it is store even though the "delete" func must know this somehow right.
//the stack allocated array size can be shown
int[7] example;
int size sizeof(example); // will return 7*4 which is the byte count of the array
int count = sizeof(example) // sizeof(int); // this will give 7 which is the actual number of integers in the array.
// we cannot do this with heap allocated arrays because we have a pointer and doing sizeof on a pointer will simply give the size of the pointer (probably 4 - the size of int), and not the size of the array.
//this also means that once we passa heap array to a function (we pass a pointer), then we cannot know the size of the array anymore. we must maintain it ourselves
//standard arrays (introduced in C++11) can be use to overcome this. standard array feature, include bounce checking and keeps track of the size of the array.
// it has an overhead but its a good way to be clean
#include <Array> //we must include it
..
std::array<int, 5> anArray; //definition. we supply with the type and also the size.
int size = anArray.size(); // this is how we get the size
--------


How Strings Work in C++ (and how to use them)
--------
string as an array of chars
the char type as the type - treat as a byte array
a character is 1 byte - ascii
character encodings (utf-8 16 32) to represent big languages

const char* name = "a name"; // basic def. reason for "const" is to be safe, memory access wise. this is of course if we dont want to change the string content
//we do not delete these allocations since we didnt use the new keyword

//ascii table

//null termination character as a way to know the end of the string
char* name2[6] = {'a',' ','n','a','m','e' };
name[2] = 'a';
print(name2); // since we didnt put a null termination, a lot of junk will be printed. until the next null character
char* name2[6] = {'a',' ','n','a','m','e', '\0'}; //this will fix the issue

IN C++ WE SHOULD THE STD STRRING
std:string str; // it is a template of the base stinrg class. a template specialization, of char type
its a char array


#include <string>

std:string str = "some string"; // str in this case will be of type "const char[]"
//note that if we need to manipulate this array, we can always cast it to a char[]
std::cout << str << std:endl;

//std:string IS A class, so we can do stuff such as
str.size();//!! awesome

//to append strings with the std::string, since its a const by definition, we must either use a constructor for one of the strings, or use the += operator to append
std::string str = "A String" + "Another string"; // ERROR
std::string str = std::string("A String") + "Another string"; // OK
std::string str = "A String"; str += "Another string"; // OK

// we can find substrings
bool contains = str.find("Another") != std::string::npos; // npos is the const definition that there's no position on that string. since "find" returns a position, this comparison will return us whethere the substring is found or not

// pass std::string to a function is BY VALUE ! meaning it sends in a copy
void func(std::string str) {
	str += "morestuff"; 
}
main(){
	std::string aStr = "stuff"; 
	func(aStr); // when the func returns, aStr will NOT BE CHANGED!
}

// sending string by reference is done by sending a CONST REFERENCE to the string
// we use const because we must NOT change the addrees reference
void func(const std::string& str) { 
	str += "morestuff"; 
}

--------



String Literals in C++
--------
"String" //the type is "const char[7]" (one more char for null termination)

const char str[7] = "Str\0ing"; // also possible but the explicit termination will cause strlen func (witthing stdlib.h) to be wrong about the string size - 3 instead of 7.

char* str = "string";
str[2] = 5; // this actually should not happen, because string literals are stored in a read only memory section. it is compiler dependent. VS C++ actually allows this.
//still IT WILL COMPILE BUT IT WONT CHANGE THE VALUE OF THE CHAR!
//in DEBUG mode it WILL throw an exception.
//literals are embedded into the binary compiled files. (exe ort dll)

//to solve this we simply define the string as an array instead of a pointer to the string.
char str[] = "string";
str[3] = 5; // this is ok and it will work on runtime
 
//there are more character types. wchar_t is a wide-char, it is 16bits character.
const wchar_t* strL = L"wide";
const char16_t* str16 = u"16";
const char32_t* = str32 = U"32";
//regular string liternal can be signed with u8"..."
const char* str = u8"normal";

// std::string_literals can ease the appending of strings.
// add the letter "s" after the concatenated literal string.
using namespace std:string_literals
std:string str = "A"s + " String";

// to ignore excape characters, we can add "R" to the beginning of the string

//const char* str = R"string
//string1
//string2
//string3
//";

--------


CONST in C++
--------
//a promise that something will not change. it can be broken..
const int MAX_AGE = 90; // a const value
int* a = new int; //create a new pointer on the HEAP!
*a = 2; //change the value that is in the interger that the pointer is pointing to (dereference)
a = (int*)&MAX_AGE; // we set the pointer to point to the constnat MAX_AGE. we cast to overcome the const keyword



const int* a = new int;  //allow pointing address change but not the content
// this is the same as writing "int const* a = new int;
*a = 2; //this will NOT work now. 
a = (int*)&MAX_AGE; //this will still work because the point address is still changeable

int* const a = new int;  //allow content change but not the pointing address
*a = 2; // this will now work but
a = (int*)&MAX_AGE; // this will NOT work

//basically its all comes to where the "*" is placed, before or after the "const" keyword


//consts will classes and methods
//putting a const on a method of a class will make it to be able to only READ values
class Foo{
	private:
		int m_bar;
	public
		int GetBar() const {
			m_bar = 2; //this will NOT work!
			return m_bar;
		}
		int SetBar() { //no const here because it is a setter
			m_bar = 2; //this will NOT work!
		}
}

// if we have a function that gets a constant reference of an object, then we cannot call any method inside that object that actually changes its values!
class Foo{
	private:
		int m_bar;
	public
		int GetBar() const {
			m_bar = 2; //this will NOT work!
			return m_bar;
		}
}
void printFoo(const Foo& foo) {
	foo.GetBar(); //this will NOT work, if the "const" word is ommited from "GetBar()"
}
main(){
	Foo f;
	f.GetBar(); // this will throw an error.
}

//we can bypass the const in this case, with the keyword "mutable"
class Foo{
	private:
		mutable int m_bar;
	public
		int GetBar() const {
			m_bar = 2; //this WILL work now!
			return m_bar;
		}
}
main(){
	Foo f;
	f.GetBar(); // this will NOT throw an error.
}
--------



The Mutable Keyword in C++
--------
//same example as above 

//ALSO, Lambda's (keyword "auto") - it is an inline function.
//when passing a var by value to a lambda, it is pretty much const.
// we can make the lambda mutable and it will fix the issue

main(){
	int x = 8;
	auto f = [=](){  //the [=] means that we pass all above variables by VALUE. [&] is be reference. to send only x, we use [&x]
		x++;
		print(x);
	}
	f(); //call the lambda
}
// the above will not work because we try to change x within the lambda.
//to fix, we use the mutable keyword
	auto f = [=]() mutable { 
		x++;
		print(x);
	}
//remember that after the lambda, x will NOT be changed cause it was sent by VALUE

--------



Member Initializer Lists in C++ (Constructor Initializer List)
--------
// a way to initialize class member in the constructor

//the following is the normal way. we can call both constructors from main
class Foo{
	private:
		std::string m_name;
		std::string m_name2;
	public
		Foo() {
			m_name = "unknown";
			m_name2 = "unknown2";
		}
		Foo(const std::string& name, const std::string& name2) {
			m_name = name;
			m_name2 = name2;
		}
}

//the better way is to use member initializer
class Foo{
	private:
		std::string m_name;
		std::string m_name2;
	public
		Foo() 
			: m_name("unknown"), m_name2("unknown2"), 
		{
		}
		Foo(const std::string& name, const std::string& name2) 
			: m_name(name), m_name2(name2), 
		{
			
		}
}

//NOTE we MUST put the variables in the order that the members are defined!
// if not, some members will be initialized twice! with the default constructor
// this can be very bad if members are objects which are very costly.

--------



Ternary Operators in C++ (Conditional Assignment)
--------
// syntax (condition) ? (do if true) : (do if false);
//these can be nested of course
--------



How to CREATE/INSTANTIATE OBJECTS in C++
--------
//instantiate - two options. on the STACK (primitive) and on the HEAP (managed).

using String = std::string;

class Foo{
	private:
		String m_name;
	public
		Foo() : m_name("unknown") {}
		Foo(const std::string& name) : m_name(name) {}
		
		const String& GetName() const { return m_Name; } 
}
main() {
	///creating on the STACK
	//these objects will be dismissed when we exit the CODE BLOCK ({})
	Foo f1; //in c#/java, this will be NULL! but not here. f is now allocated on the STACK. it is initialized with the empty constructor since we put no params
	f1.GetName(); //this will work
	
	Foo f2("bar"); 
	//Foo f2 = Foo(bar"); // exactly the same with different syntax
	print(f2.GetName()); //this will print "bar"
	
	///creating on the HEAP
	//its not enough that there's a pointer to that object, like soe
	Foo* fp;
	{
		Foo f("Bar"); //create on the stack
		fp = &f; //fp now points to f
		// at this point, f is a valid object
	}
	//here, we still have fp pointing to f, BUT f is now empty!
	//this is because f is on the stack, and the memory on that address was cleared,
	// BUT the pointer still points to that memory!
	
	//instead, we use the new keyword to instantiate f on the HEAP. also, the identifier f is now a pointer, and not just the actual var/obj
	Foo* fp;
	{
		Foo* f = new Foo("Bar"); //f is now a pointer, pointing to the new obj on the heap
		fp = &f; //fp still points to f - 
		// at this point, f is a valid object
	}
	
	//NOTE: on C#, the declaration syntax is a bit different - no "*"! in C++ we SHOULD use the stack when we can.
	// C# -  Foo  f = new Foo("Bar");
	// C++ - Foo* f = new Foo("Bar");

	//in C++ we MUST delete objects ourselves.
	Foo* fp;
	{
		Foo* f = new Foo("Bar");
		fp = &f;
		delete f;
	}
	
	//if we want to delete an object, outside of the scope that it was define, we need an additional pointer that is defined also outside
	Foo* fp;
	{
		Foo* f = new Foo("Bar"); 
		fp = &f;
	}
	delete(f); //this will NOT work
	delete(fp); //this will work
	
	
	//IMPORTANT! ACCESS an object's methods/vars:
	// when we allocate an object on the HEAP, we get back a pointer. Now we cannot access its content the same way we used to access an object that is allocated on the stack (using "."). instead, we have the "->" operator, which doing the work of dereferencing for use.
	//on the stack
	Foo f;
	f.GetName(); //this is ok
	//on the heap
	Foo* f = new Foo("Bar");
	f.GetName(); // will NOT work
	f->GetName(); // this is how its done
	
}
--------



The NEW Keyword in C++
--------
//tis an operator. goal is to allocates memory. can use on primitives 
//the allocation must find a continueus array of memory, long enough for that allocation. its pricy, "free list" makes it fast
int* b = new int; //single int
int* c = new int[50]; //array of integers
Foo* foos = new Foo[50];// also on classes, array of that class

//the new keyword not only allocates - it calles the constructor!
//it returns a void pointer and takes a size
//both lines below does exactly the same, only the first also calls the constructor
Foo* f = new Foo();
Foo* f2 = (Foo*)malloc(sizeof(Foo));

//we must delete objects we created with new
Foo* f = new Foo();
delete f;
//we can automate with smart pointers

//when using the new keyword with brackets (creating arrays), we must call the correct delete
int* i = new int[50];
delete[] i;
--------



Implicit Conversion and the Explicit Keyword in C++
--------
//some syntactic sugar. basically we can create object and give them a value, without calling the constructor in the normal way. even if we have a complex object, the value given will be implicitly converted
class Foo{
	private:
		std::string m_name;
		int m_num;
	public:
		Foo(const std::string& name) : m_name(name) {}
		Foo(int num) : m_num(num) {}
		
		const String& GetName() const { return m_Name; } 
}
main(){
	Foo f1("aName"); 
	Foo f1 = Foo(aName); //same thing
	Foo f1 = "aName"; // -> implicit construction
	
	Foo f2(2);
	Foo f2 = 2; // -> implicit construction
}

// we can use this even when calling functions
void print(const Foo& f){ ... }
main(){
	print(22); // this works
	print("aName"); // t his doesnt work because the string given is NOT an std::string. it is a const char*
	// for it to work it must do TWO conversions. const char* -> std::string -> Foo
	// but it only allowed to do a single conversions
	print(Foo("AName")); // this will work
}

//explicit keyword disables this implicite conversion!
//add it to a consructor and it will cancel the implicite feature
class Foo{
	private:
		std::string m_name;
		int m_num;
	public:
		Foo(const std::string& name) : m_name(name) {}
		explicit Foo(int num) : m_num(num) {} //we add the explicit keyword to this constructor.
		
		const String& GetName() const { return m_Name; } 
}
main(){
	print("aName"); // this will work
	print(22); // this will NOT work
}


--------


//TODO
OPERATORS and OPERATOR OVERLOADING in C++
--------
//we can override operators with specific symbols, so that they would do other oprations.
//custom operators
//overriding operators
--------


The "this" keyword in C++
--------
//accessiable only in a method (a class function)
//"this" will return the object that this method belongs to this object's class
//this is a POINTER to the current class
--------



Object Lifetime in C++ (Stack/Scope Lifetimes)
--------
//every time we enter a scope, we push a stack in
//when the scope ends everything on the stack is gone
//when using this right, it can actually be a good thing
scope = {...}

class Foo{
	public:
		Foo () {print("created"}
		~Foo () {print("destroyed"}
}
main(){
	{
		Foo f1;
		Foo* f2 = new Foo();
	}
	//at this point, f1 will no longer exist and the destructor will be called.
	//but f2's destructor will not be called. only that we dont have a pointer to it anymore.
}

//here, when the function return, the object will already be destroyed
//this is bad! this function is not usable
int* createArray()
{
	int array[50];
	return array; 
}
//instead we must  create it outside where we need it
//alternatively we can create the array in the func, but on the HEAP. then it will be kept

//A good solution is to make use of smart pointers
// a scope pointer is a good example

class ScopedPtr{
	private:
		Foo* m_Ptr;
	public:
		ScopedPtr(Foo* ptr) : m_Ptr(ptr) {}
		~ScopedPtr() {delete m_Ptr;}	
};
main(){
	{
		ScopedPtr foo = new Foo(); //NOTE! foo here is allocated on the STACK! the "new Foo()" creates a new Foo and returns a pointer, which goes to the constructor of ScopedPtr. the new is not for the ScopedPtr but for the Foo
	}
	//at this point, the destructor of Foo will be called
}
//the above behavior shows how one of the smart pointers called "unique_ptr" works.

//A GOOD unique use of the this behavior is to measure a time a block is executing
//we create the timer when the block opens, and that's it. when the block is done, the destructor will be called automatically, so we can put some code there like time calculations. one line of code to measure time.
--------



SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)
--------
//allows avoiding calling "new" & "delete". its done automatically.
//std::unique_ptr (lighter), std::shared_ptr (heavy), std::weak_ptr
//VERY USEFUL - automate memory management stuff, very safe.

///unique_ptr - when the pointer goes out of scope, the object will get deleted.
// cannot copy unique pointers for obviouse reasons
#include <memory>
class Foo{
	public:
		Foo () {print("created"}
		~Foo () {print("destroyed"}
		void Print() {...}
};
main(){
	{
		std::unique_ptr<Foo> aFooPtr(new Foo());
		//access functions of Foo is done via the pointer so we need the -> operator
		aFooPtr->Print();
		//more correct initialization is to call "make_unique"
		std::unique_ptr<Foo> aFooPtr2 = std::make_unique<Foo>(); //safer way.
		
		// we cannot copy unique pointers
		std::unique_ptr<Foo> someptr = aFooPtr2; //will not compile
	}
	//at this point the unique pointer will call the destroy of the Foo object
}


///shared_ptr - using reference counting - counts how many reference do we have to out pointer
//shared pointers can be copied unlike unique pointers
//we MUST call "make_shared" to create such a pointer
main(){
	{
		std::shared_ptr<Foo> sharedPtrL1;
		{
			std::shared_ptr<Foo> sharedPtrL2 = std::make_shared<Foo>(); //ref count = 1
			sharedPtrL1 = sharedPtrL2; //this is ok now   //ref count = 2
		}
		//at this point the Foo instance still lives, because although sharedPtrL2 got deleted, sharedPtrL1 still exist
	}
	//here, the Foo instance will be deleted
}

///weak_ptr - same as shared (can be copied), but the ref count does NOT change
// can be used to simply check if the object still lives.
// if we replace the sharedPtrL1 above to be "weak_ptr", then the Foo instance will get deleted right after we exit the most inner scope. 
--------



Copying and Copy Constructors in C++
--------
//copy constructors
//copy when required and avoid copy if not desired

struct Vec2{
	float x,y;
	//...ctor....
}
main(){
	Vec2 a = Vec2(1,1);
	Vec2 b = a; //b here is A COPY! because a and b are NOT pointers
	
	Vec2* c = new Vec2(1,1);
	Vec2* d = c; //NOT a copy. only one Vec2, with two pointers
	d->x = 5; //this will affect both c.x & d.x
}


//<a complicated example>  showing shallow copy versus deep copy.
//basically, if we create an instance (on stack), and then create another one but it is equal to the first, and the class of these instances has a pointer, THE POINTEERS WILL BE COPIED! this can make a lot of issues
//for this reason we can write a "copy constructor" - a construtor that is called for the second string, when we actually copy it.
//if we create "Foo f1("Str")" with values, then create "Foo f2 = f1", the copy constructor will make sure that the pointer in the class that points to the data is NOT copied with its value (the address is NOT copied). instead, we COPY the entire data and create a new pointer to that new data. this is deep copy. 
//in the example on the video, the copy constructor copies all members that are NOT pointers, and then allocate all the variables that are pointed, and do a complete value copy.

class String{
	..... //members (int mSize, char* m_Buffer), constructors
	
	//copy constructor
	String(const String& org)
		: m_Size(org.m_Size)
	{
		m_Buffer = new char[m_Size + 1];  //1 for null termination
		memcpy(m_Buffer, org.m_Buffer, m_Size);
		m_Buffer[m_Size] = 0; //null termination
	}
	
	....methods, desctructor
}

main(){
	String str1 = "str";
	String str2 = str1; // here, the copy constructor will automatically be selected and called, and a deep copy is made
	
	str2[2] = 'B';
	
	//if we print both str1 & str2, we can see that the modification to str2 was only on that object and str1 remains the same!
}

//if we want a function to print the string, we must pass it by reference, because if not then, the passing of the parameter will create another redundant copy of those objects

void Print(String string) {..print..} //this will make another copy - a deep copy in this case
void Print(const String& string) {..print..} //this is now passed by ref so no copies are made for the call. 

//we can also make copies in the print func, if we have to do some changes to the incoming string
void Print(const String& string){
	String copy = string; // copy is now a deep copy of param string
	..print..
}
--------




The Arrow Operator in C++
--------
// "->"  - this operator looks better. it dereference a pointer, and then call the desired func
class Foo{
	public:
		void Print() const { ..print..}
};
main(){
	Foo f1;
	f1.Print(); //this works well
	
	Foo* ptr = &f1; //a new pointer to our instance
	
	//to call Print using the new pointer, we can do deferencing so we get the object itself, and then we can use the "." to call Print
	(*ptr).Print();
	
	//BUT WAIT! we can use the "->" to make this easier
	ptr->Print();
}
//also works for members of course


// We can overload this operator. one case is that maybe we want to create a ScopedPtr like before, and use it when creating our Foo object so the deletion will be automatic.
// if we don, then we must overload the -> operator because the ScopedPtr wraps the Foo instance,
class Foo{
	public:
		void Print() const { ..print..}
};
class ScopedPtr{ 
	private:
		Foo* m_Ptr;
	public:
		ScopedPtr(Foo* ptr) : m_Ptr(ptr) {}
		~ScopedPtr() {delete m_Ptr;}	
		*Foo operator->() { return m_Ptr; }
};
main(){
	ScopedPtr PtrToFoo = new Foo();
	PtrToFoo->Print(); //this will NOT work without the -> op overloaded
	
	//we CAN make a new method that simply returns the pointer, but its too much code than what we actually need. sometihng like "void GetObj() { return m_Ptr; }"
	// this works but its not that nice.
	ScopedPtr PtrToFoo = new Foo();
	PtrToFoo.GetObj().Print();  
}


//another usage with the operator is to get absolute locations in a structure
struct Vec3{ float x,y,z; };
main(){
	
	int offset = (int)&((Vec3*)nullptr)->y;
	// first we take something that is null - nullptr.
	// then we cast it to Vec3, so we can refere to it as a structure.
	// then we select the member "y" with the arrow operator
	// then we get the mem address of that "y"
	// finally we cast it to an integer.
	//the example above will print "4" because y is located 4 bytes relative to the start of the object
}
--------



Dynamic Arrays in C++ (std::vector)
--------
//uses a template - requires to be given a type (generics in c# ? )
//can resize. very costly. can be optimized.


struct Vertex { float x,y,z; };

////override the << operator for Vertex type so it can be printed easly
std::ostream& operator<<(&std::ostream stream, const Vertex& vertex) {
	stream << vertex.x << ", " << vertex.y << ", " << vertex.z; 
	return stream;
}
////

#include <vector>

main(){
	std::vector<Vertex> vertices; //
	// std::vector<int> vec; //unlike java, we CAN pass here a primitive. i dosnt have to be an object
	// std::vector<Vertex*> vertices;  // we can also do a vector of pointers. its valid
	// BUT, storing stuff like that will destroy the identation of the objects - i.e. in memory they wont be in a single file line one after the other. it would be just pointers, and the actual data will be all over the place. in case of vertices, its way more efficient to have them line up, like in the first code line above
	
	// add two new vertices
	vertices.push_back({ 1, 2, 3 });
	vertices.push_back({ 4, 5, 6 });
	
	//iterate with for loops - note that we have access to the size of the array!
	for (int i=0; i< vertices.Size(); i++){
		std::cout << vertices[i] << std::endl;
	}
	
	//iterate with range based for loops. we use a reference (&) so the elements will not be copied while iterated over
	for (Vertex& v : vertices)
		std::cout << v << std::endl
	
	vertices.clear(); //clear the entire vector 
	vertices.erase(vertices.begin() + 1); // erase specific vertex. NOTE - we cannot simply write "vertices.erase(3);" because its more complicated. we need an iterator. luckely, we have "vertices.begin()" and to that we add the offset of 1 and that means we remove the second element
	
	
	//Passing it to a function, we WANT to send it by ref, so it wont be copied.
	// check out the function declaration below
	Func(vertices);
}

void Func(std::vector<Vertex>& vertices) {...}
--------




Optimizing the usage of std::vector in C++
--------
//<TODO>
--------




Using Libraries in C++ (Static Linking)
--------
// static means that we attached the binaries directly into our executable (embed?).
// dynamic library can be loaded on the fly, on runtime, as an external dll.
// 32/64 bit binary? get the correct one for your project!
//<TODO> continue
--------



Using Dynamic Libraries in C++
--------
//<TODO>
--------



Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)
--------
//<TODO>
--------




--------
--------




--------
--------




--------
--------



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------