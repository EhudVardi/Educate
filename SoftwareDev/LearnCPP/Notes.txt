//Learn CPP
//---------


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//https://www.youtube.com/watch?v=bFtkHJy9kIU&t=3798s
//70* Experienced C++ Interview Questions
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//------------------
//friend function
//------------------

//allow access into a class method from outside

//it is like declaring a function in a class without definition, then give definition from outside the class (use same func name to connect). this func definition will be able to access private members that belong to that class, but it will NOT have access to privates that are inherited

//friend is just your friend (class) and not you parents and g-parents (base classes)

class Base {
	int x;
public:
	Base() {}
	Base(int x):x{x} {}
	friend void func(Base &);
};

void fun(Base &obj) {
	cout << obj.x << endl;
	obj.x = 20;
}

void main() {
	Base b(10);
	fun(b);
	
	return 0;
}

//------------------


//------------------
//auto keyword in C++
//------------------

// automatically derive the type by the value assigned.
// not included in CPP legacy
// i integer, d double, <classname> class, p pointer

#include <iostream>
#include <typeinfo>
using namespace std;

class Base {};

int main() {
	auto x = 20;  
	auto y = 20.5;
	auto b = Base(); // init in stack
	auto c = Base(); // init at heap - pointer
	
	cout << typeid(x).name() << endl; // i
	cout << typeid(y).name() << endl; // d
	cout << typeid(b).name() << endl; // 4Base
	cout << typeid(c).name() << endl; // P4Base
	
	return 0;
}

//------------------


//------------------
//Code bloating. 
//------------------

//1. creating variables that are not required to have a life time
// creating a string var is not needed because we just print it. 
// instead, print the text directly.
#include <iostream>
using namespace std;
int main() {
	string str("EV");
	cout << str << endl;
	cout << "EV" << endl;
	return 0;
}

//1. inline function mass calls
// an inline function is copied at compile time.
// if there's a statement that do that, the code will bloat
#include <iostream>
using namespace std;
class Base {
	int _x;
public:
	inline void print() { /* some code */ }
}
int main() {
	Base b1;
	b1.print();b1.print();b1.print();b1.print();b1.print();
	return 0;
}


//------------------
//constant cast in CPP
//the expression const_cast<T>(v) can be used to change the const or volatile qualifiers of pointers or references.
//T must be a pointer, reference or pointer-to-member type

//RULES WHEN TO USE THIS
// 1 only when we have to
// 2 only when the actual refered obj/var is NOT const
// 3 only when dealing wiht 3rd party lib and some API want data in non const form but we have it in const form. we have to make sure the API doesn't make changes to it.

//------------------

// examples below will compile but will produce unexpected results.

// case 1:
#include <iostream>
using namespace std;

int main() {
	const int a1 = 10;
	const int *b1 = &a1;
	int *d1 = const_cast<int*>(b1);
	*d1=15; 
	cout << a1 << endl;  //print "10". the compiler will optimize and replace "a1" with "10"
	cout << *d1 << endl; //prints 15! should be the same
	
	int a2 = 20;
	const int *b2 = &a2;
	int *d2 = const_cast<int*>(b2);
	*d2=30;  // this will work because the original variable a2 is not constant, so there's no problem
	cout << a2 << endl;   // both will print the same value
	cout << *d2 << endl;
	
	return 0;
}


// case 2:
//if we want to pass a const var of our own to a 3rd party lib that needs to get a non-const var, then we can use the const_cast
// note that the function does not set anything into x which is important
void thirfPartyFunc(int* x) {
	int k = 10;
	cout << k+*(x);
}

int main() {
	const int x = 20;
	const int* px = &x;
	thirfPartyFunc(const_cast<int*>(px));
	thirfPartyFunc((px));  //this line will not compile
	return 0;
}


//case 3: remove the volatile modifier so a variable will be optimized
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}

//------------------






//------------------
// One of the usages of the keyword "decltype"
// It checks the type of the expression
//------------------

// in this example, the template return type is T2 which is the second param to the Typed func "add"
// the code will output 2.8 and then 2, this is inconsistant
#include <iostream>
using namespace std;

template<typename T1, typename T2>
T2 add (T1 a, T2 b) { 
	return a+b;
}

int main() {
	
	cout << add(1, 1.8) << endl;
	cout << add(1.8, 1) << endl;
	return 0;
}

//to solve this we can use "decltype" to automatically assert the type
//the code below will print 2.8 and then 2.8 which is desired
//decltype(a+b) figures out that one of the params are given in float so it has to elevate the other to float too.
#include <iostream>
using namespace std;

template<typename T1, typename T2>
auto add (T1 a, T2 b) -> decltype(a+b){ 
	return a+b;
}

int main() {
	
	cout << add(1, 1.8) << endl;
	cout << add(1.8, 1) << endl;
	return 0;
}
//------------------



//------------------
// **IMPORTANT!**
// what is the difference between a pointer and a reference
//------------------

// a reference is NOT a variable of its own, like pointers. it can be considered as an alias
// 1. (Mem Addr) have the same address as the var refered (unlike pointer)
// 2. (Reassignment) unlike pointers re-assignment of a reference is NOT possible 
// 3. (NULL) unlike pointers a reference MUST BE ASSIGNED A VALUE at declaration point!
// int &r; -> this is illegal.
// 4. (Arithmetic ops) unlike pointers, references cannot have arithmetic operations applied to.
// int &r = i;
// r++; // this is illegal!
// 5. (Indirection) a reference cannot have another reference refering to it, unlike pointers
// int i = 10;
// //pointer p can have indirect pointers pointing to it.
// int* p = &i;
// int **pp = &p;  //indirect pointer to pointer p
// int ***ppp = &pp;  //indirect pointer to pointer pp
// //references can only have 1 level reference. its like re-aliasing the same symbol
// int &r = i;
// int &rr = r; // this is ok. both rr and r with have THE SAME VALUE


#include <iostream>
using namespace std;

int main() {
	
	int i = 10;
	int &r = i; //this is a reference to i
	int *p = &i; //this is a pointer to i
	
	// print all three definition addresses
	// this will print that &i and &r have THE SAME ADDRESS, while &p will have a different address, since a pointer is a variable of its own
	cout << &i << '\t' << &r << '\t' << &p << endl;
	
	return 0;
}
//------------------



//------------------
// differences between range based for loops and for_each loops
// 1. 
// 2.
// 3.
// 4.
//------------------

#include <iostream>
#include <vector>
#incldue <algorithm>
using namespace std;

void print(int val) {cout << val <<endl; }

int main() {
	
	//  create and populate the array with simple for loop
	vector<int> vec;
	for (int i=0; i<5; i++) {
		vec.push_back(i);
	}
	
	// get each element into i (i is NOT an index but the value)
	// - cannot define the range or iteration
	for (int i: vec)
		cout << i <<endl;
	
	// giving a start point and end point at the vector, and then giving a anonimous function that will be executed for each element i.
	// - can define the range with  "vec.begin()+2" for ex
	for_each(vec.begin(), vec.end(), 
		[](int i) {
			cout << i <<endl;
		}
	);
	
	// same as above but giving a named function "print". the param type must match!
	for_each(vec.begin(), vec.end(), print);
	
	return 0;
}
//------------------



//------------------
// dynamic_cast int CPP
// syntax: dynamic_cast<Type_To_Cast_To>(Expression)
// used at runtime to find out correct down-cast
// 1. at least one virtual function at base class
// 2. if cast success it will return a value of Type_To_Cast_To
// 3. if cast fails - 
//    type_To_Cast_To is pointer type then a NULL pointer will be returned
//    type_To_Cast_To is a reference type then a std::bad_cast exception will be thrown.
// "down cast" = base->child | "up cast" = child->base
//------------------
#include <iostream>
using namespace std;

class Base {
	virtual void print() { cout << "Base" << endl; }
};
class Derived1: public Base {
	void print() { cout << "Derived1" << endl; }
};
class Derived2: public Base {
	void print() { cout << "Derived2" << endl; }
};

int main() {
	Derived1 d1;
	
	// this works - cast d1 down to Base class
	//NOTE - this is an "up" cast which is also legal. 
	Base *bp = dynamic_cast<Base*>(&d1); 
	// this will NOT work since bp is a pointer of type Base and it attemps to cast it up the wrong child type (was "Derived1" and tried to cast to "Derived2"
	//NOTE - this is a "down" cast which is also legal. 
	Derived2 *dp2 = dynamic_cast<Derived2*>(bp);  //dp2 = NULL
	
	// this cast will work
	Derived1 *dp3 = dynamic_cast<Derived1*>(bp); //dp3 = an object
	
	try {
		Derived1 &r1 = dynamic_cast<Derived1&>(d1); // this will pass
		Derived2 &r2 = dynamic_cast<Derived2&>(d1); // this will throw exception
	} catch (std::exception& e) {
		cout << e.what() << endl;
	}
	return 0;
}
//------------------



//------------------
// explicit constructor
// using explicit ctor helps avoid implicit call to the constructor
//------------------
#include <iostream>
using namespace std;

class Basese {
	int b_var;
public:
	Base() {}
	Base(int var) : b_var(var) {}
	//explicit Base(int var) : b_var(var) {}  // same ctor with explicit modifier
	void print() { std::cout << b_var << std::endl; }
}

void fun (Base b) {
	b.print();
}

int main() {
	
	// if the ctor "Base(int var)" does not have the "explicit" modifier, then the code below will compile and work.
	
	Base obj1(10); // normal ctor call
	Base obj2 = 20; // implicit call to the constructor "Base(int var)"
	// also works passing to functions
	fun(obj1); // normal ctor call
	fun(30); // implicit call to the constructor Base(int var)
	
	return 0;
}
//------------------



//------------------
// "extern c" in cpp code
// used when we want to include c code into our cpp code
// the issue arise since cpp compiler mangles (modifies) all function names (we can see the given symbols (names) by the compiler in the *.o files generated) to achieve overloading.
// the solution is to encapsulate the #include statment with the phrase "extern "C" {}
//------------------

#include <iostream>
// "cfile.h" is a c header file that contains a function "func".
// the included func will get its name changed at compile time
#include "cfile.h" 
// including it like this will prevent the compiler from modifying the func name 
extern "C" {
	#include "cfile.h"
}

using namespace std;
int main() {
	
	func();
	return 0;
}
//------------------



//------------------
// function chaining
// calling multiple methods on an object that each returns itself so the entire call chain can be written in one line.
//------------------
#include <iostream>
using namespace std;

class Base {
	int _a,_b;
public:
	Base& funcA(int a) { _a = a; return *this; }
	Base& funcB(int b) { _b = b; return *this; }
	void print() { cout << _a << "," << _b <<< endl; }
}
int main() {
	
	Base b;
	b.funcA(1).funcB(2).print(); 
	return 0;
}
//------------------



//------------------
// function hiding in c++
// when we define a function in a derived class where the base class has a func with the same name, but with different param type. the Base func will not be called
// to explicitly call it, we can use SCOPE RESOLUTION -> <instance>.Base::func(param)
// another way is to insert the base function func in the scope of the derived class, by using "using Base::func;" which puts the base class func visible at the derived class and so it makes it available
//------------------
// TODO
#include <iostream>
using namespace std;

class Base {
public:
	void func(int a) { cout << "Base" << endl; }
}
class Derived: public Base {
public:

	using Base::func; // adding this line will add the base class func into the derived scope
	
	void func(char c) { cout << "Derived" << endl; }
}
int main() {
	Derived d;
	
	d.func(1);
	d.func('a'); // this will not call the case function
	
	d.Base::func(1); // this will call the base func since we are using scope resolution
	
	return 0;
}
//------------------



//------------------
// function pointer
// stores an address of a function. 
//// good use case example -> passing the "qsort" function a "compare" function which will allow the "qsort" to be generic and be able to sort any type of array/structure.
qsort(Arr,ArrLength,elementSize,compare) //compare is a pointer to our own compare function


//// for function with signature 
int add(int a, int b) {return a+b;}
// defining a pointer to this function (define and assign address)
// must match the signature of the function to point to
int (*funcPTR)(int,int) = &add; // traditional way
int (*funcPTR)(int,int) = add; // new compiler's way
// using the pointer to call the function
int c = (*funcPTR)(1,2); // traditional way
int c = funcPTR(1,2); // new compiler's way

//// passing a function as an argument
int funcThatGetsPassedTheFuncPTR(int (*someFunc)(int,int)) {\
	return someFunc(3,4);
}
void main() {
	
	printf("%d", funcThatGetsPassedTheFuncPTR(add));
	
}

//// returning a function pointer as an agrument
int add(int a, int b) {return a+b;}
int sub(int a, int b) {return a-b;}

typedef int(*arithmeticFunc)(int,int); //define the type of the function that returns a airthmetic function by type, so it will be readable
arithmeticFunc getFunc(int type) {
	if (type == 1)
		return add;
	if (type == 2)
		return sub;
}
void main() {
	int (*someFunc)(int,int); // the pointer to our function
	someFunc = getFunc(1); // set the pointer to the add func
	printf("%d", someFunc(2,3)); // call it using the pointer and print.
}

//*******
// we can replace this
typedef int(*arithmeticFunc)(int,int);
arithmeticFunc getFunc(int type) { .. }
// with this
int (*getFunc (int type))(int,int) { .. }
//*******

//// using arrays of function pointers
int add(int a, int b) {return a+b;}
int sub(int a, int b) {return a-b;}
typedef int(*arithmeticFunc)(int,int);
void main() {
	arithmeticFunc funcArr[2] = {add, sub}; // array of two func pointers
	int added = funcArr[0](1,2);
	//int added = (*funcArr)[0](1,2);  //legacy 
	int subed = funcArr[1](1,2);
	//int subed = (*funcArr[1])(1,2);  //legacy 
}
//*******
// we can replace this
typedef int(*arithmeticFunc)(int,int);
arithmeticFunc funcArr[2] = {add, sub};
// with this
int (*funcArr[2])(int,int) = {add, sub};
//*******

//------------------



//------------------
// functor
// TODO: 1:38:45
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// what is gdb and how to use it to debug
// 1:40:50
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// what is compiler linker and loader
// TODO: 1:52:20

// diagram #1
//-------------------------------------------------------------------------------------
// source -> compiler -> obj |
// source -> compiler -> obj |-> linker -> [exectuable] -> loader -> [runnig exec in mem]
// source -> compiler -> obj |
//            [library file] |
//-------------------------------------------------------------------------------------

// diagram #2
//-------------------------------------------------------------------------------------
//									IDE (source code writing)
//										|
//										|	(.cpp, .h) source code and header files
//										|
//									preprocessor
//										|
//										|	(*.i) include files, replaced symbols
//										|
//									compiler
//										|
//										|	(*.s) assembly code
//										|
//									Assembler
//										|
//										|	(*.o) object code
//										|
//	static Libraries (.lib, .a) --->Linker
//										|
//										|	(.exe)
//										|
//	dynamic Libraries (.dll, .so)--->Loader
//										|
//										|
//										|
//									operating system
//-------------------------------------------------------------------------------------

//------------------



//------------------
// delete[] - how does delete[] (delete on array) knows the size of the array if we use a pointer?
// answer - at array init we give a size. at that point we store it somewhere.
// two ways to store it:
// 1. Over allocation - we add more memory to the array where we store that size, and at de-allocation time we get that size from there and de-allocate the entire block.
// 2. Associative array - maintaining a separate array where we store pointer+size ([*p, SIZE]) and at deallocation we search for that pair and take the SIZE from there.
//------------------
//TODO:
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// local static variable in a template function
//TODO:
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// "this" pointer in C++
// it is hiddenly passed as argument to non static member functions
// it is a const pointer [Type* const this]
// if the member function is const (in case of a "get" method for example where values are read but not write) than this pointer type is passed as const  [const Type* const this]
//------------------
//TODO:
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to assign any object to a primitive data type? 
// answer - define the operator <primitive_type>() in the class
// TODO: 2:26:14
//
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to call function before main
// TODO: 2:29:16
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to check if two different objects belong to the same class in c++
// answer - useing #include <typeinfo>
// TODO: 2:31:58
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to overload pre and post increment operator in c++
// TODO: 2:33:36
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to print N times without a loop or recursion
// print in class ctor and init an instance N times
// TODO: 2:38:50
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to set/clear/toggle/check one bit in of an integer var
// TODO: 2:40:14
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// how to stop an object from being copied
//------------------

// 1st way - keep copy constructor and assignment operator private
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
private:
	Base(const Base& obj): _x{obj._x} {}
	Base& operator = (const Base& rhs) { _x = rhs._x; return *this;}
};

int main() {
	Base b1(10);
	Base b2(20);
	
	Base b3(b1);	// -> this will produce an error 
	b1 = b2;		// -> this will produce an error 
	return 0;
}
//------------------

//------------------
// 2nd way - inherit dummy class with private copy constructor and assignment operator
// -> this will separate the Base class from the code that blocks the copy
#include <iostream>
using namespace std;

class StopCopy {
public:
	StopCopy() {}
private:
	StopCopy(const StopCopy& obj) {}
	StopCopy& operator = (const StopCopy& rhs) { return *this; }
};

class Base : public StopCopy {
	int _x;
public:
	Base() : _x{0} {}
	Base(int x) : _x{x} {}
};


int main() {
	Base b1(10);
	Base b2(20);
	
	Base b3(b1);	// -> this will produce an error 
	b1 = b2;		// -> this will produce an error 
	return 0;
}
//------------------

// 3rd way - delete copy ctor and assignment operator from your class - cleaner
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
	Base(const Base& obj) = delete;
	Base& operator = (const Base& rhs) = delete;
};

int main() {
	Base b1(10);
	Base b2(20);
	
	Base b3(b1);	// -> this will produce an error 
	b1 = b2;		// -> this will produce an error 
	return 0;
}
//------------------

//------------------
// how to prevant taking the address of my instance of an object

// 1st way: overload the reference (&) operator and set its visibily scope to private
//------------------
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
private:
	Base* operator & () { return this; }
};

int main() {
	Base b;
	cout << &b << endl;
	return 0;
}
//------------------

// 2nd way: delete the reference & operator from the class
//------------------
#include <iostream>
using namespace std;

class Base {
	int _x;
public:
	Base() {}
	Base(int x) : _x{x} {}
	Base* operator & () = delete;
};

int main() {
	Base b;
	cout << &b << endl;
	return 0;
}
//------------------



//------------------
// how to prevent inheriting from a class
// -> use "final" keyword on the base class that we wish to ceil.
// TODO: 3:00:30
//------------------
#include <iostream>
using namespace std;

class Base final {
	int _var1;
public:
	Base() {}
	Base(int var1) : _var1(var1) {}
};

class Derived: public Base {
	int _var2;
public:
	Derived() {}
	Derived(int var1, int var2): Base(var1), _var2(var2) {}
};

int main() {
	Derived d(1,2);
	return 0;
}
//------------------



//------------------
// how to write my own atoi func
//------------------
#include <iostream>
using namespace std;

int my_atoi(char *str) {
	
	if (str[0] == '\0')
		return 0;
	
	int res = 0;
	bool sign = true;
	int i = 0;
	
	if (str[0] == '-') {
		sign = false;
		i++;
	}
	else if (str[0] == '+')
		i++;
	
	while (str[i] != '\0') {
		if (str[i] < 48 || str[i] > 57)
			break;
		res = 10*res + str[i]-48;
		i++;
	}
	
	if (!sign)
		res = -res;
	
	return res;
}

int main() {
	
	cout << atoi("-1234") << "," << my_atoi("-1234") << endl;
	
	return 0;
}
//------------------



//------------------
// How vectors work internally in cpp STL
// -> capacity doubles everytime the size reach to capacity
//------------------
#include <iostream>
#include <vector>

using namespace std;

int main() {
	std:vector<int> vec;
	
	int i = 30;
	do {
		vec.push_back(i);
		cout << "capacity=" << vec.capacity() << endl;
		cout << "size=" << vec.size() << endl;
		i--;
	}while (i > 0);
	
	return 0;
}
//------------------



//------------------
// how to call a constructor and destructor explicitly
// for objects in the stack this should NOT be done explicitly!
//------------------
#include <iostream>
using namespace std;

class Base {
	int var;
public:
	Base () { cout << "ctor" << endl; }
	~Base () { cout << "dest" << endl; }
};

int main() {
	cout << "before nameless instance" << endl;
	Base(); // ** this is an interesting case. since the object is instantiated temporary (we do not give it any name as a variable), as soon as the next line is executed, this object is not pointed by anyone and so the constructor is immediately called
	cout << "after nameless instance" << endl;
	
	Base b; // explicit call to constructor
	b.~Base(); // explicit call to destructor -> should not do it because the object is in the stack and we want to compiler to handle the destruction of the object.
	
	
	return 0;
	
} /// -> here the instance "b" goes out of the scope and thus its destructor will be called again implicitly.


//------------------


//------------------
// cpp optimization checking website ->  https://godbolt.org
//------------------


//------------------
// function overloading - Name mangling
// compiler extends the symbols of the overloaded functions and so it compiles
//------------------
#include <iostream>
using namespace std;

void print(int val) {  } // this func name is renamed to  "_Z5printi"
void print(double val) {  }  // this func name is renamed to  "_<prefix>printd"

int main() {
	
	return 0;
}
//------------------



//------------------
// object slicing in cpp
// when creating a base object by copying from a derived object, the derived data will not be copied (duh..)
// in the example below, "Base b_obj = d_obj;" will copy only b_var data of d_obj into the b_var of the new b_obj.
// this is called object slicing because the derived objcet instance data is sliced into the base object instance
//------------------
#include <iostream>
using namespace std;

class Base {
public:
	int b_var;
	Base() { cout << "Base ctor" << endl; }
	~Base() { cout << "Base dest" << endl; }
};
class Derived: public Base {
public:
	int d_var;
	Derived() { cout << "Derived ctor" << endl; }
	~Derived() { cout << "Derived dest" << endl; }
};

int main() {
	Derived d_obj;
	Base b_obj = d_obj;	
	cout << "exit" << endl;
	return 0;
}
//------------------



//------------------
// efficient and cool algorithm to count '1' bits of a binary number
// amazing how it works
//------------------
#include <iostream>
using namespace std;

int numOnes_normal(int binNum) {
	
	int count = 0;
	while (binNum) {
		count += (binNum & 1);
		binNum >>= 1;
	}
	return count;
}
int numOnes_BrianKernighanAlgo(int binNum) {
	
	int count = 0;
	while (binNum) {
		binNum &= (binNum-1);
		count++;
	}
	return count;
}


int main() {
	for (int i=0; i<32; i++) {
		cout << "num=" << i << "\t(normal,BrianKernighanAlgo)= " << numOnes_normal(i) << ", " << numOnes_BrianKernighanAlgo(i) << endl;
	}
	return 0;
}
//------------------



//------------------
// override in cpp (cpp v11 and above)
// -> seems like override in cpp does not require the "override" keyword to override base fucntions.
// it is a good practice to put it because
// 1. testing becomes easy because the maintenance is easier
// 2. more important, a compile time check is performed and in case the overrided function signature does not match the virtual base one, and the override keyword was added, then the compiler will alert about the signature mismatch
//------------------
#include <iostream>
using namespace std;

class Base {
	int b_var;
public:
	virtual void fun() { cout << "base" << endl; }
}
class Derived {
	int d_var;
public:
	void fun() { cout << "derived" << endl; } // this already overides the base func
	void fun() override{ cout << "derived" << endl; } // nothing will change here.
	void fun(int a) { cout << "derived" << endl; } // here the signature mismatch so the base func is not overrided. the override keyword is not used here so the compiler won't alery
	void fun(int a) override{ cout << "derived" << endl; } // same mismatch but the override keyword is used so the compiler will alert
}

int main() {
	Base* b = new Derived();
	b->fun();
	return 0;
}
//------------------



//------------------
// placement new in C++
// -> when using the "new" keyword, we are switching to kernel mode from user mode to search for adequate space fot the new object. it is an overhead to the system in general. (switching to kernel is a hursh operation)
// if this is done many times, this overhead becomes a problem.
// -> the solution is to explicitely allocate memory for all the object instances that we required ahead of time. it is called a "memory pool".
// this way if we need 10 instances, we call the kernel only once to create the pool.
// -> create a memory pool (char[] memory) in the size of the class, times the amount of instances
// -> when creating each object, provide the address of the memory which the object will be placed into, in the memory pool. note that we have to set the memory location identation correctly. if the object size in byte is S, then each instantiation have to skip S bytes from the last object.
// finally when finishing using the pool (destructing all objects), we delete the pool itself
//------------------
#include <iostream>
using namespace std;

class Base {
public:
	Base() { cout << "ctor" << endl; }
	~Base() { cout << "dest" << endl; }
};

int main() {
	
	cout << "normal case" << endl;
	Base* obj = new Base();
	delete obj;
	
	
	cout << "placement new case" << endl;
	char* memory = new char[10*sizeof(Base)]; // Base size if 4 bytes so memory is 40 bytes
	Base* obj1 = new (&memory[0]) Base();
	Base* obj2 = new (&memory[4]) Base();
	Base* obj3 = new (&memory[8]) Base();
	
	obj1->~Base();
	obj2->~Base();
	obj3->~Base();
	
	delete[] memory;
	
	return 0;
}
//------------------



//------------------
// reinterpret_cast in C++
// TODO: 3:40:20
// -> this use is never safe for anything other than casting back to the original type
// -> if we use this cast then the code becomes "non-portable" -> meaning it is now specific hardware dependent since we are assuming how the HW is defining the types in the memory (int can be 2 can be 4 and can be 8 bytes for ex.). we are loosing the hardware abstraction.

// This is dangerous because it can typecast any pointer type to any other pointer type
//------------------
#include <iostream>
using namespace std;

class Mango {
public:
	void eatMango() { cout << "eating mango" << endl; }
};
class Banana {
public:
	void eatBanana() { cout << "eating banana" << endl; }
};
int main() {
	Banana* b = new Banana();
	Mango* m = new Mango();
	
	Banana* newBanana = reinterpret_cast<Banana*>(m);
	newBanana->eatBanana();
	
	return 0;
}
//------------------

// Good usage - if we want to treat a type data in a different way.
// in the example below we create an instance of the struct and then creating an int* pointer that points to it but as if it was an actual integer. this way we can access its memory structure as if it was an integer array.
// -> this reminds me of the Union keyword that allows to share the same memory with multiple structure definitions
//------------------
#include <iostream>
using namespace std;

struct myStruct {
	int x; // 4 byte
	int y; // 4 byte
	char c; // 2 byte
	bool b; // 2 byte
};

int main() {
	
	myStruct s;
	s.x = 5; s.y = 10; s.c = 'a'; s.b = true;
	
	int* p = reinterpret_cast<int*>(&s);
	
	cout << sizeof(s) << endl;
	
	cout << *p << endl; // will print s.x -> 5
	p++;
	cout << *p << endl; // will print s.y -> 10
	p++;
	cout << *p << endl; // will print (int)s.c + (int)true*0xFF -> 256 + 97 = 353
	
	// we can separate the character by doing reinterprete again to char
	
	char* c = reinterpret_cast<char*>(p);
	cout << *c << endl;
	
	// since the char pointer points to a 2 byte memory chunk, we can use it to point to the boolean after it. this is NOT possible using the integer pointer since it points to 4 byte chunks and we will skip over it.
	c++;
	bool* b = reinterpret_cast<bool*>(c);
	cout << *b << endl;
	
	return 0;
}
//------------------





//------------------
// static_cast in C
// TODO: 3:54:42
//------------------

// When to use and why:
// 1. when converting compatible types (e.x. float to int)
// 2. when calling conversion operator and conversion constructor
// 3. to avoid (and get a compiler error) when trying to convert unmatched types
// 4. to avoid conversion of derived instance into a private base pointer.
// 5. use always when up-casting (derived to base) but never use for down-casting (base to derived) - there's not runtime checks for static_cast conversions
// 6. explicitly defines casting intensions. make it easier to debug and manage (search)
// 7. errors are found at compile time which is very important.

// 6 examples below that illustrate these points:


// program 1
// performs implicit conversions between types
// easy to search and find all casts in the code.
// the cast will happend AT COMPILE TIME
#include <iostream>
using namespace std;

int main() {
	float f = 3.5;
	int a;
	
	// both below lines are doing THE SAME
	// searching for all casts is very easy when we use "static_cast"
	// this helps greatly to find and analyze casting in the code.
	a = f;
	a = static_cast<int>(f);
	
	return 0;
}
//------------------


// program 2
// used when conversion between types is provided with conversion operator or conversion constructor.
// 
#include <iostream>
using namespace std;

class Int {
	int x;
public:
	// conversion constructor - will be called when an instance gets an assignment to a value, as if it was of that primitive type. 
	Int(int x=0): x{x} { cout << "conversion constructor" << endl; }
	// conversion operator - will be called when a instance of this class is used as a string.
	operator string () {
		cout << "conversion operator" << endl;
		return to_string(x);
	}
};

int main() {
	Int obj(3);
	
	string str1 = obj;  // conversion operator is called implicitly
	obj = 20;	// conversion constructor is called implicitly
	
	// same happens here but we explicitly casting using the static_cast
	string str2 = static_cast<string>(obj); // conversion operator is called explicitly
	obj = static_cast<Int>(30);	// conversion constructor is called explicitly
	
	return 0;
}
//------------------


// program 3
// static_cast is more restrictive than C-style cast.
// e.x.  char* to int* is allowed in C-style cast but not with static_cast
#include <iostream>
using namespace std;

int main() {
	char c; 			// 1 byte data
	int *p = (int*)&c;  // 4 byte data
	*p = 5;				// compiles but fails are run-time - will allow access mem that should not be accessed
	
	int* ip = static_cast<int*>(&c); // FAIL at compile time!, because pointer types mismatch. this help avoid from the previous example
	
	return 0;
}
//------------------


// program 4
// static_cast prevents casting from derived class to a private base pointer
// ** private inheriting means that any class that inherit from the derived classs will not have access to its derived class
// i.e.
// assume: class Base {};  class Derived: private Base {};
// class Derived2: public Derived {};
// the class Derived2 will not have access to Base class elements

#include <iostream>
using namespace std;

class Base {};
class Derived: private Base {}; // the derivation here is private

int main() {
	Derived d1;
	Base* bp1 = (Base*)&d1; // this is allowed at compile time but IT IS NOT DESIRED!
	Base *bp2 = static_cast<Base*>(&d1);  // this will fail at compilation 
	return 0;
}
//------------------


// program 5
// static_cast used for all up-casts (cast derived to base), but should never be used for down-casts (cast base to derived), because with down-cast we don't know the true type of the instance. this is because up-cast we always have one parent but down-cast we can have many childs
// the example below will compile but it is incorrect!
#include <iostream>
using namespace std;

class Base {};
class Derived1: public Base {};
class Derived2: public Base {};

int main() {
	Derived1 d1;
	Derived2 d2;
	
	Base* bp1 = static_cast<Base*>(&d1); // upcast d1 to base pointer bp1
	Base* bp2 = static_cast<Base*>(&d2); // upcast d2 to base pointer bp2
	
	Derived1 *d1p = static_cast<Derived1*>(bp2); // downcast with a mixup. d2->d1
	Derived2 *d2p = static_cast<Derived2*>(bp1); // downcast with a mixup. d1->d2
	
	return 0;
}
//------------------


// program 6
// static_cast is recommended when casting to and from a void* pointer
#include <iostream>
using namespace std;

int main() {
	int i = 10;
	void* v = static_cast<void*>(&i);
	int* ip = static_cast<int*>(v);
	return 0;
}
//------------------





//------------------
// structural padding & packing in C & CPP
// TODO: 4:10:15
// -> the padding i was working on in the protocol message structures. packing removes the padding which wastes memory but optimize read because reading is simpler. (padding in structure is by the largest element defined inside it. also, when defining a structure within a structure, the padding will be by the largest primitive, within the inner strucure as well as the outer stcruture.
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// difference between Enum & Enum class
// TODO: 4:36:55
// -> class simply adds scope so the names of the enum values are separated from other types.
// -> also, class enum values cannot be converted to integers easly (like normal enums, which always takes by default the values 0, 1, 2, etc)
// -> if we define two separate regular enum which does not have any connection in terms of meanings, they could still be compared (because of the default values described above).
//------------------
#include <iostream>
using namespace std;

int main() {
	
	return 0;
}
//------------------



//------------------
// Two Ways To Return Multiple Values From Functions In C++
// 4:46:53 
// -> normal is to define a struct that will hold these values.
// -> other way is to use tuples. we can declare the output variables outside and then pass them into as a tuple, or we can use the "auto" keyword and then use the "get" and the value position in the tuple to retrieve the values.
//------------------
#include <iostream>
#include <string>
#include <tuple>
using namespace std;

tuple<int, char, string> fun() {
	return make_tuple(1,'a',"str");
}
int main() {
	
	int n, char c, string s;
	auto tup = fun();
	n = get<0>(tup);
	c = get<1>(tup);
	s = get<2>(tup);
	
	return 0;
}
//------------------



//------------------
// Virtual Destructor In C++?
// 4:51:43 
// ctors are called by what type of object their pointer hold, but dests are called by the type of the pointer!

//------------------
#include <iostream>
using namespace std;

class Base {
public:
	virtual void fun() { cout << "Base fun" << endl; }
	Base() { cout << "Base ctor" << endl; }
	~Base() { cout << "Base dest" << endl; }
	//virtual ~Base() { cout << "Base Dest" << endl; }
	// if we make the dest virtual then the derived dest will be called also (the derived dest and then the base)
};
class Derived : public Base {
public:
	virtual void fun() { cout << "Derived fun" << endl; }
	Derived() { cout << "Derived ctor" << endl; }
	~Derived() { cout << "Derived dest" << endl; }
};

int main() {
	// b1 is of type Base and is held by a Base pointer - Base ctor will be called
	Base* b1 = new Base(); 
	// b2 is of type Derived and is also held by a Base pointer - Derived ctor will be called
	Base* b2 = new Derived();
	
	b1->fun();// will call the Base fun version
	b2->fun();// will call the Derived fun version
	
	delete b1; // this will call the Base dest
	delete b2; // ** if the Base dest is not virtual, then this will not call the Derived dest!
	
	return 0;
}
//------------------



//------------------
// Where do we HAVE to use Initialiser List In C++?
// 4:57:14 
//------------------


// case 1: when we want to init a non-static const member of a class, we must use init list and we cannot do it within the ctor itself.
#include <iostream>
using namespace std;

class Base {
	const int _x;
public:
	Base() : _x{0} {}
	Base(int x) : _x{x} {}
	//Base() { _x=0; }  //-> this will give a compiler error
	//Base(int x) { _x=x; }   //-> this will give a compiler error
};
int main() {
	Base b1(10);
	Base b2(20);
	
	return 0;
}


// case 2: when we want to init a non-static reference that is a member of a class, we must use init list and we cannot do it within the ctor itself
#include <iostream>
using namespace std;

class Base {
	int& _x;
public:
	Base() : _x{0} {}
	Base(int x) : _x{x} {}
	//Base() { _x=0; }  //-> this will give a compiler error
	//Base(int x) { _x=x; }   //-> this will give a compiler error
};
int main() {
	Base b1(10);
	Base b2(20);
	
	return 0;
}


// case 3: when we want to init one class type with another class type, we must use init list if the first class type does not have a default ctor.
#include <iostream>
using namespace std;

class One {
	int _x;
public:
	//One( : _x{0} {} // a default ctor 
	One(int x) : _x{x} {}
};
class Two {
	One _a;
public:
	Two(One x) : _a{x} {}
	// Two(One x) {_a = x;}  -> this will not work unless "One" will have a default ctor
};

int main() {
	One one(10);
	Two two(one);
	
	return 0;
}


// case 4: when we want to init a Base class members when calling a Derived class.
#include <iostream>
using namespace std;

class Base {
	int _b;
public:
	Base(int b) : _b{b} {}
};
class Derived : public Base {
	int _d;
public:
	Derived(int b, int d) : Base{b}, _d{d} {}
	//Derived(int b, int d) { _b=b; , _d=d; } -> this will not work
};

int main() {
	Derived d(1,2);
	return 0;
}


// case 5: when the name of a ctor parameter matches the member name itself (not _x=x  but _x=_x)
#include <iostream>
using namespace std;

class Base {
	int _b;
public:
	Base(int _b) : _b{_b} {}
	//Base(int _b) { _b=_b; } // this will obviously won't work.
};

int main() {
	Base b(1);
	return 0;
}


// case 6: when in one class we have a member of another type of class that is used by a ctor to init itself, if we do not use the init list then it will create a copy of that another class, adding an overhead. by using the init list we do not make a copy of the given another class at init time.
#include <iostream>
using namespace std;

class Another {
	int _x;
public:
	Another () { cout << "another default ctor" << endl; }
	Another (int x) { _x=x; cout << "another parameter ctor" << endl; }
	Another (const Another& obj) { this->_x = obj._x; cout << "another copy ctor" << endl; }
	Another& operator = (const Another& obj) { cout << "another assignment operator" << endl; }
};
class MyClass {
	Another _a;
public:
	MyClass() { cout << "MyClass default ctor" << endl; }
	
	// output:
	//another parameter ctor
	//another copy ctor
	//another copy ctor
	//MyClass parameter ctor
	MyClass(Another a) : _a{a} { cout << "MyClass parameter ctor" << endl; }
	
	// output:
    //another parameter ctor
    //another copy ctor
    //another default ctor
    //another assignment operator
    //MyClass parameter ctor
	//   MyClass(Another a) { _a=a; cout << "MyClass parameter ctor" << endl; }
};

int main() {
	Another a(1);
	MyClass mc(a);
	
	return 0;
}

//------------------



//------------------
// What Are The Drawbacks Of Using Vector In C++?
// TODO: 5:11:42 
// vectors use simple arrays in the background, so the following happens
// 1. it over allocates memory (capacity grows by factor of two)
// 2. when the capacity changes (doubles), it COPIES ALL ELEMENTS from PREVIOUS vector to a new vector!
//------------------
#include <iostream>
#include <vector>
using namespace std;

int main() {
	vector<int> vec;
	
	for (int i=0; i<100; i++) {
		cout << "size: " << vec.size() << "\tcap: " << vec.capacity() << "\taddr: " << &vec << endl;
		vec.push_back(i);
	}
	return 0;
}
//------------------



//------------------
// What Is Constructor Delegation In C++?
// 5:16:19 
// -> similar to ctor in C# where we chain constrctor call to another constructor to reuse the same code.
// not only the initilization of the members will be written once, but all the other initialization required will be written into ctor3 just once.
//------------------
#include <iostream>
using namespace std;

class Base {
	int _a, _b;
public:
	Base(): Base{0,0} {}   //ctor1 -> calls ctor3(0,0)
	Base(int a): Base{a,0} {}   //ctor2 -> calls ctor3(a,0)
	Base(int a, int b): _a{a}, _b{b} {}   //ctor3  -> list init _a & _b
};

int main() {
	Base b1();
	Base b2(10);
	Base b3(10,20);
	return 0;
}
//------------------



//------------------
// What Is Return Value Of printf And scanf In C & C++?
// 5:20:21 
// printf returns the number of characters that were printed
// scanf returns the number of elements that were read from the console , where elements are basically lines
//------------------
#include <iostream>
#include <stdio.h>
using namespace std;

int main() {
	int printOut = printf("%s", "hello world\n"); //12 chars
	cout << printOut << endl;
	
	char str[100];
	int scanIn = scanf("%s", str); // 1 element scanned
	cout << scanIn << endl;
	int val;
	scanIn = scanf("%s %d", str, &val); // 2 elements scanned
	cout << scanIn << endl;
	
	return 0;
}
//------------------



//------------------
// What Is RVO And NRVO Copy Elision In C++?
// 5:22:18 
// RVO - return value optimization
// NRVO - named return value optimization
// -> when compiling there's a flag that can disable some optimization invlovling calling copy constructor without any real need.
// -fno-elide-constructors
// adding this switch  to the compile command will cause the example below to output
// ctor
// copy ctor
// copy ctor
// this is because it disabled the optimization and the function call and the assignment are both calling the copy constructor 
//------------------
#include <iostream>
using namespace std;
class Base {
public:
	Base() { cout << "ctor" << endl; }
	Base(const Base&) { cout << "copy ctor" << endl; }
};
Base func() { 
	return Base();
}
int main() {
	Base b = func();
	return 0;
}
//------------------



//------------------
// What Is The Best Place To Use Enum In C++?
// 5:26:15 
// -> when we know beforehand the entire set of possible values for a specific problem. for ex - colors.
//------------------
#include <iostream>
using namespace std;

enum class Color {red, blue, green, };
void fun(Color c) {
	switch (c) {
		case Color::red: cout << "red" << endl; break;
		case Color::blue: cout << "blue" << endl; break;
		case Color::green: cout << "green" << endl; break;
	}
}
int main() {
	fun(Color::red); fun(Color::blue); fun(Color::green);
	return 0;
}
//------------------



//------------------
// What Is The Difference Between struct And class In C++?
// 5:28:42 
//------------------
// 1. memebr default visibility is private for classes and public for structs
#include <iostream>
using namespace std;

class classBase {
	int _c;
};

struct structBase {
	int _s;
};
int main() {
	classBase cb;
	structBase sb;
	cout << sb._s << endl;
	cout << cb._c << endl; // should not work
	return 0;
}
// 2. inheritance default visibility is private for classes and public for structs
#include <iostream>
using namespace std;

class BaseClass {};
class DerivedClass: private BaseClass; // the private here is not required

struct BaseStruct {};
struct DerivedStruct: public BaseStruct; // the public here is not required

int main() {
	return 0;
}
//------------------



//------------------
// What Is The Order Of Function Parameter Evaluation In C++?
// 5:32:10 
// -> the order of parameter evaluation is un-defined! it is up to the compiler to decide. what is promised is that all parameters will be evaluated BEFORE the call to the function (duhh..)
// executing the example below in 
// "https://www.programiz.com/cpp-programming/online-compiler/"
// shows that calling a function with two params, th SECOND param is evaluated first and only then the FIRST param will.
//------------------
#include <iostream>
using namespace std;

int param1() { cout << "param1" << endl; return 1; }
int param2() { cout << "param2" << endl; return 2; }
void func1Param(int a) { cout << a << endl; }
void func2Params(int a, int b) { cout << a << ", " << b << endl; }
int main() {
	func1Param(param1() + param2());
	func2Params(param1(), param2());
	return 0;
}
//------------------



//------------------
// When To Use Reference Over Pointer and Vice Versa In C++?
// 5:34:48 

// -> REFERNCE: use in func params and return types.
//-------------------------------------------

// 1. (optional usage) pass big objects by reference
#include <iostream>
using namespace std;
class BigClass { public: int _data; /* a lot of data */ };
void funcV(BigClass obj) { } // pass by value - will copy the entire object
void funcR(BigClass& obj) { obj._data; } // using a reference - to pass the big object by ref 
void funcP(BigClass* obj) { obj->_data; } // using a pointer - will have to use the arrow operator which is less nice.
int main() {
	BigClass obj;
	funcV(obj);
	funcR(obj); // pass with reference also allows us to not use the & symbol
	funcP(&obj);
	return 0;
}

// 2. (optional usage) avoid object slicing
#include <iostream>
using namespace std;

class Base {
public: virtual void print() { cout << "base print" << endl; }
};
class Derived: public Base {
public: virtual void print() { cout << "derived print" << endl; }
};
void funcV(Base obj) { obj.print(); }  // by val - will slice the object
void funcR(Base& obj) { obj.print(); } // by ref - will keep the object

int main() {
	Derived d;
	funcV(d); // will print the base - object sliced
	funcR(d); // will print the derived - object maintained
	return 0;
}

// 3. (optional usage) modify local vartiable of caller function (common use)
#include <iostream>
using namespace std;
void funcModifyVar(int& val) { val = val+10; }
int main() {
	int val = 1;
	funcModifyVar(val);
	cout << val << endl;
	return 0;
}

// 4. (optional usage) achieve runtime polymorphism in a function (similar to obj slice)
#include <iostream>
using namespace std;

class Base {
public: virtual void print() { cout << "base print" << endl; }
};
class Derived: public Base {
public: virtual void print() { cout << "derived print" << endl; }
};
void func(Base& obj) { obj.print(); } // same function can get two varients and call different functions in one line - polymorphism

int main() {
	Base b; Derived d;
	func(b); func(d); 
	return 0;
}

// 5. essential usage - in copy constructors we MUST use references
#include <iostream>
using namespace std;

class Base {
	int _x;
public: 
	Base (int x): _x{x} {}
	Base (const Base& b): _x{b._x} {}  // copy constructor - must pass the copied object by ref
	void print() { cout << "x=" << _x << endl; }
};
int main() {
	Base b(5);
	Base b1 = b;  //call to copy constructor
	b.print(); b1.print();
	return 0;
}


// -> POINTERS: use in algorithms and data structures like linked-lists, trees, graphs, etc.
//-------------------------------------------
// 1. its possible to put null in a pointer (ref does not allow)
// 2. its possible to change pointer address (ref pointed address is constant)



//------------------
// Which Is Faster pre OR post Increment With Proof In C & C++?
// 5:43:20 
// use godbolt.org to analyze the code below in assembly to see the difference
// basically since we first add to i and then set its value to j, it takes one assembly atom command less.
//------------------
#include <iostream>
using namespace std;

int main() {
	int i = 10;
	int j = 20;
	j = i++; // post-increment
	j = ++i; // pre-increment
	return 0;
}
//------------------



//------------------
// Why Copy Constructor Take Argument As Reference?
// 5:48:36 
// the reason is very interesting. passing an object by value to a function will incure a copy of the object (pass by value always copy the parameter being passed).
// a copy constructor must get an instance of an object to use its data to copy.
// this means that if we pass the object to copy to the copy constructor value, it will incure a copy which means the same copy constructor will be called AGAIN!
// this will cause an infinite loop 
//------------------
#include <iostream>
using namespace std;

class Foo {
	int _bar;
public:
	Foo() {}
	Foo(const Foo& obj) { _bar = obj._bar; }
	//Foo(const Foo obj) { _bar = obj._bar; }  // pass by value will incure a copy which will create an infinite loop..
	void setBar(int newBar) { _bar = newBar; }
};
int main() {
	Foo f1;
	f1.setBar(5);
	Foo f2 = f1;
	return 0;
}
//------------------



//------------------
// Why Must Define Static Data Member of Class In Cpp File?
// 5:51:16 
// -> it will create "multiple definitions" compile time error
// this is because the "foo.h" header is included twice - in app.cpp and in foo.cpp.
// these multiple includes will create multiple definitions error
// the correct way is to declare at the header file and define at the code file
//------------------
#include <iostream>
#include "foo.h"
using namespace std;

//FILE: app.cpp 
int main() {
	Foo obj1, obj2;
	o1.setNormal(10); // o1 - own memory for normalVariable
	o2.setNormal(5);  // o2 - own memory for normalVariable
	// o1 and o2 will have common memory for staticVariable (a trait of static vars)
	cout << o1.getNormal() << endl;
	cout << o2.getNormal() << endl;
	
	o1.setStatic(60);
	cout << o2.getStatic() << endl;
	return 0;
}
//FILE: app.cpp END

//FILE: foo.cpp 
#include "foo.h"

int Foo::staticVariable = 10;  ///*** defining here will avoid the multiple definitions

Foo::Foo() { normalVariable = 0; }
Foo::Foo(const Foo& obj) { normalVariable = obj.normalVariable; }

void Foo::setNormal(int newVal) { normalVariable = newVal; }
int Foo::getNormal() { return normalVariable; }

void Foo::setStatic(int newVal) { staticVariable = newVal; }
int Foo::setStatic() { return staticVariable; }
//FILE: foo.cpp END

//FILE: foo.h 
class Foo {
	int normalVariable;
	static int staticVariable;
public:
	Foo();
	Foo(const Foo&);
	void setNormal(int);
	int getNormal();
	void setStatic(int);
	int getStatic();
};

int Foo::staticVariable = 10; ///*** defining here will create multiple definitions

//FILE: foo.h END

//------------------



//------------------
// Why Prefer Pass By Reference Or Pointer Over Pass By Value?
// 5:54:08 
// save us from copying big objecs
//------------------
#include <iostream>
#include <vector>
using namespace std;

#define size 1000

//void foo(vector<int> vec) { // pass the vec by value - make a copy!
//void foo(vector<int>& vec) {  // this is the correct way - pass the vec by ref
void foo(const vector<int>& vec) {  // tpass by ref and also make it const. this is good if  the function only read values and do not change anything
	for (auto v: vec) { 
		cout << v << ", ";
	}
	cout << endl;
}
int main() {
	vector<int> vec(size);
	for (int i=0; i<size; i++) {
		vec[i] = i+1;
	}
	foo(vec);
	return 0;
}
//------------------



//------------------
// Why Returning Reference Is Bad Some Time In C++?
// 5:57:30 
// -> when returning a reference of a local variable it is not good since the variable will be removed when the function returns, so the reference is meaninigless
// the code below will result in a compiler error
//------------------
#include <iostream>
using namespace std;

int& func() {
	int a = 10;
	return a;
}
int main() {
	int& a = fun();
	cout << a << endl;
	return 0;
}

//the code below will work because we are giving a reference and returning the same reference
#include <iostream>
using namespace std;

int& func(int& i) {
	i += 10;
	return i;
}
int main() {
	int i = 5;
	cout << i << endl;
	int& a = func(i);
	cout << a << endl;
	return 0;
}
//------------------



//------------------
// Why Size Of Empty class OR struct Is One In C++?
// 6:00:23 
// empty structures and classes size in CPP is NOT ZERO. it is 1! why?
// this is because if there's nothing to differentiate between instances (i.e. values of members) then the compiler must insert something to differentiate!
// if we will add a simple integer, the size will be 4 (integer size) and not 5 (integer+1)
//------------------
#include <iostream>
using namespace std;
struct EmptyS {};
class EmptyC {};
int main() {
	cout << sizeof(EmptyS) << endl;
	cout << sizeof(EmptyC) << endl;
	return 0;
}
//------------------



//------------------
// Why Template Functions Only Defined Inside Header Files?
// 6:04:54 
// TODO  - what is the reason?
//------------------

/// in the example below the declaration of the template is on the header, but the definition is on the code file. this will NOT compile.
/// -> to make it compile we must put the definition as well as the declaration into the header.
/// but this is unwanted since we mix declaration and definition into the same file!
/// -> (solution I) one way to solve this we can keep the definition in the code file and simply use "#include" in the header file, right after the declaration.
/// -> (solution II) another way is to instantiate specific types for the class template so that the compiler won't have to create them and in this process re-create the issue.



//FILE: foo.h 

#ifndef foo_h
#define foo_h

#include <iostream>
/// DECLARATION
template<typename T> 
class Foo {
	T _val;
public:
	T getValue();
	void setValue(T val);
};
/// DECLARATION END

///** the DEFINITION should be here so the project will compile

/// (solution I) use include
#include "foo.cpp"

#endif

//FILE: foo.h END


//FILE: foo.cpp 

#include "foo.h"
/// DEFINITION
template<typename T> 
T Foo::getValue() { return _val; }
void Foo::setValue(T val) { _val = val; }
/// DEFINITION END

/// (solution II) define class templates with specific types that we are going to be using
template class Foo<int>;  // define a class template for int type
template class Foo<float>;  // define a class template for float type
// ....


//FILE: foo.cpp END


//FILE: app.cpp 
#include "foo.h"
using namespace std;
int main() {
	Foo<int> obj;
	obj.setValue(5);
	cout << obj.getValue() << endl;
	return 0;
}
//FILE: app.cpp END


//------------------




//------------------
// Why Using Namespace Std Is Bad To Use?
// 6:11:24
// -> the question is actually - why putting the line "using namespace std;" and then using "cout" for example, without the namespace prefix "std" ("cout << .." instead of "std::cout << ...")
// the reason is because we might get a name collision with other libraries that might get included in the future which would have some elements that carry the same names.
// basically it is a good practice to write everything with the namespace prefix before any call to that namespace, instead of just putting the "using namespace .." clause
//------------------

// instead of this
#include <iostream>
using namespace std;
int main() {
	cout << "test" << endl;
	return 0;
}
// do this
#include <iostream>
int main() {
	std::cout << "test" << std::endl;
	return 0;
}

//------------------




//------------------
// Why vector Was Introduced In C++?
// 6:14:17 
// -> it is using arrays in conjunction with linkedlists
//  when a vector has to increase its capacity, a linked list structures is used. increasing capacity using an array structures is not optimized.
//  when accessing an element at specific index, an array structures is used. using a linkedlist structures to access an element at specific index is not optimized
// in conclusion, we get the benefits from both data structures
//------------------
#include <iostream>
#include <vector>

int main() {
	std:vector<int> vec;
	
	std::cout
	return 0;
}
//------------------



//------------------
// Why We Return Reference from Copy Assignment Operator?
// 6:16:59 
// -> this allows us to do assignment chaining 
//------------------
#include <iostream>
using namespace std;
class Base {
	int _var;
public:
	Base() {}
	Base(int val): _var{val} {}
	Base& operator = (const Base& rhs) { 
		_var = rhs._var;
		return *this;
	}
	void print() { cout << _var << endl; }
};

int main() {
	Base b1(10);
	Base b2, b3, b4;
	
	// chaining the assignments.
	// b4 is set to b1, and b4 ref is returned
	// b3 is set to b4, and b3 ref is returned
	// b2 is set to b3, and b2 ref is returned (but the ref is not used - end of chain)
	b2 = b3 = b4 = b1;
	// print all 
	b1.print(); b2.print(); b3.print(); b4.print();
	
	return 0;
}
//------------------



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
https://www.youtube.com/watch?v=zUy66Bats5c
Threading In C++ | Complete Course
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//------------------
// Introduction
// 00:00:00 - 
// * main is a default thread for the process of our program, from which we "fork" (create) more threads.
// * a thread is in some terms a lightweight process. unlike process, it shares memory with other threads.
// * creating a thread (c++11 and above) is achieved with Function pointers, Lambda fucntions, functors member functions and static member functions.
//
//------------------

// example - sum all odd numbers and even numbers, in a given large range
// when using threads we get parallel execution which shortens the exec' time

#include <iostream>
#include <thread>  // c++11 and above
#include <chrono>  // to measure exec' time
#include <algorithm>

using namespace std;
using namespace std::chrono;

typedef unsigned long long ull;  // shorthand alias

ull evenSum = 0;
void findEven(ull start, ull end) {
	for(ull i = start; i<= end; ++i) {
		if ((i & 1) == 0) {
			evenSum += i;
		}
	}
}
ull oddSum = 0;
void findOdd(ull start, ull end) {
		for(ull i = start; i<= end; ++i) {
		if ((i & 1) == 1) {
			oddSum += i;
		}
	}
}

int main() {
	ull start = 0, end = 2000000000;
	
	cout << "executing without threads..." << endl;
	auto startTime = high_resolution_clock::now();
	
    findEven(start, end);
    findOdd(start, end);
	
	auto duration = duration_cast<microseconds>(high_resolution_clock::now() - startTime);
	
	cout << "odd sum = " << oddSum << endl;
	cout << "even sum = " << evenSum << endl;
	cout << "duration = " << duration.count()/1000000.0 << endl;
	
	
	cout << "executing with threads..." << endl;
	startTime = high_resolution_clock::now();
	
	oddSum = evenSum = 0;
	// create and start running findEven & findOdd
	std::thread tEven(findEven, start, end);
	std::thread tOdd(findOdd, start, end);
	// join both threads to main thread - meaning it will block the main thread until both threads finished
	tEven.join();
	tOdd.join();
	
	duration = duration_cast<microseconds>(high_resolution_clock::now() - startTime);
	
	cout << "odd sum = " << oddSum << endl;
	cout << "even sum = " << evenSum << endl;
	cout << "duration = " << duration.count()/1000000.0 << endl;

	return 0;
}
//------------------





//------------------
// Different Types To Create Threads In C++11
// 00:18:00 - 
//------------------

// 1. with function pointer
//------------------
#include <iostream>
#include <thread>  // c++11 and above

void fun(int x) {
	while (x --> 0) {
		std::cout << x << std::endl;
	}
}
int main() {
	std::thread t(fun, 10);  // function name is used as the pointer
	t.join();
	
	// creating multiple threads - no guarantee which will start first
	std::thread t1(fun, 10);
	std::thread t2(fun, 20);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------

// 2. Lambda function
//------------------
#include <iostream>
#include <thread>

int main() {
	
	// injecting lambda expression directly to main
	auto fun = [](int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
	};
	
	std::thread t(fun, 10); // call the lambda function
	t.join();
	
	return 0;
}
//------------------

// 3. Functor (function object) - using a class special "()" operator to define its functionality as a runnable class.
//------------------
#include <iostream>
#include <thread>

class Base {
public:
	void operator ()(int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
	}
};

int main() {
	std::thread t(Base(), 10);  // pass the class as the function
	t.join();
	return 0;
}
//------------------

// 4. Non-static member function
//------------------
#include <iostream>
#include <thread>

class Base {
    int _y;
public:
    Base() {}
    Base(int y): _y{y} {}
	void run(int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
		std::cout << _y << std::endl;
	}
};

int main() {
	Base b(50);
	// creating the thread. passing the member function of the base as the function pointer (using reference because its a class). since its a non-static function, we need to also pass the class instance so we pass &b. we send it by reference to avoid copying the object
	std::thread t(&Base::run, &b, 10);
	t.join();
	
	return 0;
}
//------------------

// 5. Static member function
//------------------
#include <iostream>
#include <thread>

class Base {
public:
	static void run(int x) {
		while (x --> 0) {
			std::cout << x << std::endl;
		}
	}
};

int main() {
	Base b;
	// creating the thread. passing the member function of the base as the function pointer (using reference because its a class). since its a static function, we dont need to send and instance of an object
	std::thread t(&Base::run, 10);
	t.join();
	
	return 0;
}
//------------------




//------------------
// "Join", "Joinable" & "Detach" In C++11 Threading
//TODO: 00:25:32 - 

// Join. once a thread has started, calling "join" will block the current execution flow and wait for it to finish
// It is possible to ask if a thread is "joinable" meaning if a join call was not called upon it already.
// "joinable" is used to avoid calling join on a thread that has finished or did not start, which means it is not joinable. calling join on it on situations like this will terminate the program.
// IMPORTANT! if any thread will not get a call to either join or detach, then if the thread is still running and the program exits, it will call the thread's destructor which will check if it is still joinable and if so, it will terminate it.
//------------------
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;
using namespace std::chrono;

void run(int x) {
	while ( x--> 0)
		cout << x << endl;
	this_thread::sleep_for(chrono::seconds(3));
	cout << "thread finished" << endl;
}
int main() {
	// t1 JOIN
	thread t1(run, 5);
	cout << "before t1 join" << endl;
	t1.join();
	cout << "after t1 join" << endl;
	// here the thread has already finished. if we call join again it will terminate the entire program
	
	// t2 JOINABLE
	thread t2(run, 5);
	cout << "before t2 is joinable" << endl;
	t2.join();
	if (t2.joinable()) {
		cout << "is joinable" << endl;  // will be printed if the previous join is commented.
		t2.join();
	}
	cout << "after t2 is joinable" << endl; // this will print after the thread will finish, proving join is blocking the main thread.
	
	// t3 DETACH
	thread t3(run, 5);
	cout << "before t3 detach" << endl;
	if (t3.joinable()) {  // only detach if joinable
		t3.detach(); // we call detach which will exit the program before t3 will end
	}
	cout << "after t3 detach" << endl; // this will be printed immediately, and t3 will not get to print its output
	
	this_thread::sleep_for(chrono::seconds(4)); // if we sleep for more than 3 secs before main exists, then t3 will get to finish its job and print its output
	
	cout << "program finished" << endl;
	return 0;
}
//------------------





//------------------
// Mutex In C++ Threading
// 00:42:41 -
//  Race condition - when two threads are trying to change shared data in parallel. obviously it is an issue.
// Critical section - a section of code that r/w shared data and might run in parallel and thus expose a chance of race condition.
// Mutex (mutual exclusive) - a binary semaphore that is used to control access to critical section, such that only one thread can execute it at a time.
// Mutex has two functions - lock and unlock (release). 
//------------------
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int moneyAmount = 0;

void addMoney() {
    for (int i=0; i<1000000; ++i)
        ++moneyAmount;
}

std::mutex m;
void addMoneyThreadSafe() {
    m.lock();
    for (int i=0; i<1000000; ++i)
        ++moneyAmount;
    m.unlock();
}

int main() {

    std::thread t1(addMoney);
    std::thread t2(addMoney);
    t1.join();
    t2.join();
    cout << "not safe result: " << moneyAmount << endl;

    moneyAmount = 0;
    std::thread t1ts(addMoneyThreadSafe);
    std::thread t2ts(addMoneyThreadSafe);
    t1ts.join();
    t2ts.join();
    cout << "thread safe result: " << moneyAmount << endl;

    return 0;
}
//------------------




//------------------
// Mutex Try Lock
// 00:58:56 - 
// mutex.try_lock() attempts to lock the mutex. it returns immediately with true or false, where if returned true, the mutex is promised to be locked.
// try_lock() is non blocking (as opposed to lock()) - it returns immediately.
// if try_lock() is called again by the same thread after already returned true, it will produce an undefined behaviour, basically a "dead-lock". (there is a possibility to lock a mutex more than once, called recursive_mutex)
//
// there are various try_lock function
// 1. std::try_lock
// 2. std::mutex::try_lock
// 3. std::shared_lock::try_lock
// 4. std::timed_mutex::try_lock
// 5. std::unique_lock::try_lock
// 6. std::shared_mutex::try_lock
// 7. std::recursive_mutex::try_lock
// 8. std::shared_time_mutex::try_lock
// 9. std::recursive_timed_mutex::try_lock
//
//------------------

// 2. std::mutex::try_lock  (lock method of a single mutex)
// since we only try to lock, some iterations (of both threads) will be missed and so the final result in counter will be unexpected.
// if we instead use the simple blocking lock(), the result will always be the same as expected
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int counter = 0;
int N = 100000;
std::mutex mtx;

void increaseCounterNTimes() {
    for (int i=0; i<N; ++i) {
        if (mtx.try_lock()) {
            ++counter;
            mtx.unlock();
        }
    }
}

int main() {

    std::thread t1(increaseCounterNTimes);
    std::thread t2(increaseCounterNTimes);
    t1.join();
    t2.join();

    cout << "counter increased up to " << counter << endl;

    return 0;
}
//------------------

// 2. std::mutex::try_lock
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int counter = 0;
int N = 100000;
std::mutex mtx;

void increaseCounterNTimes() {
    for (int i=0; i<N; ++i) {
        if (mtx.try_lock()) {
            ++counter;
            mtx.unlock();
        }
    }
}

int main() {

    std::thread t1(increaseCounterNTimes);
    std::thread t2(increaseCounterNTimes);
    t1.join();
    t2.join();

    cout << "counter increased up to " << counter << endl;

    return 0;
}

//------------------




//------------------
// std::try_lock In C++11 Threading
// 01:09:33 - 
// 1. std::try_lock  (try locking multiple mutexes in series)
// syntax: std::try_lock(m1, m2, m3, m4,.. ,mn);
// * try_lock() can have multiple mutexes as arguments. when called, it will try to lock each one in the orders they were passed. if all locks were successful, then it will return -1. if it failed to lock one of the mutexes, it will return a 0-based index of the mutex that failed to be locked, based on the order of how that mutex was passed (e.x. mutex 3 lock failed - return 2)
// * on failure to lock any of the passed mutexes, the function will release all mutexes it has locked before the failure.
// * if a call to try_lock result in an exception, unlock is called for any locked objects before rethrowing.
//------------------

// example: we have two threads, two mutexes and two shared resources, one for each thread.
// each thread locks its own mutex, updates its resource, unlocks its mutex and then sleep for a second.
// a third thread is running in the background, constantly trying to lock both mutexes. while both first two threads are sleeping, the third thread will get to lock both mutexes and then consume the values in both resources of the two threads.
// * notice that the third thread is using try_lock while the first two threads are using lock, which blocks then from continuing. this is intended so if one of the first two threads are trying to lock its own resource, it will have to wait until the third thread will finish using its value.
// ** std::ref() is a reference wrapper and is required when passing elements by reference to it at thread initialization	
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

int X=0, Y=0;
std::mutex m1, m2;

// put calling thread to sleep for "secs" seconds
void doWorkForXSecs(int secs) { 
	std::this_thread::sleep_for(std::chrono::seconds(secs)); 
}

// the job for the first two threads. for X times, update its own resource and then sleep to allow third thread to consume the updated values
void incrementXorY(int& XorY, std::mutex& m, const char* desc) {
	for (int i=0; i<5; ++i) {
		m.lock();
		++XorY;
		cout << desc << XorY << endl;
		m.unlock();
		doWorkForXSecs(1);
	}
}

// the job of the third thread. constantly try to lock both mutexes and on success, use the values and then release the mutexes so the first two threads can continue their work.
void consumeXnY() {
	int useCount = 5;
	int XplusY = 0;
	while (1) {  // endless loop that must be broken
		int lockResult = std::try_lock(m1, m2);  // try locking both mutexes in order to use both shared resources X and Y. if the result is -1 then we successfuly locked both 
		if (lockResult == -1) { 
			if (X != 0 && Y != 0) {
				--useCount;
				XplusY += X+Y; // use the shared resources.
				X = Y = 0; // zero the resources after being used.
				cout << "XplusY " << XplusY << endl;
			}
			m1.unlock(); m2.unlock(); // unlock both mutexes! - a must.
			if (useCount == 0) break; // break the loop if we used the shared resources for the amount of times that was pre-defined.
		}
	}
}

int main() {
	
	std::thread t1(incrementXorY, std::ref(X), std::ref(m1), "X ");  
	std::thread t2(incrementXorY, std::ref(Y), std::ref(m2), "Y ");
	std::thread t3(consumeXnY);
	
	t1.join();
	t2.join();
	t3.join();
	
	return 0;
}
//------------------




//------------------
// Timed Mutex In C++ Threading
// 01:21:07 - 
// 4. std::timed_mutex::try_lock
// this mutex can block and try to lock for specified amount of time, after which it will return false since it failed to lock. if lock achieved in the alloted time it will return true.
// available methods:
// "lock", "try_lock" and "unlock" - the same as regular mutex
// "try_lock_for" - try to lock until acquired or until a duration elaped.
// "try_lock_until" - 
//------------------

// example: "try_lock_for"
// we create two threads and run the same job. the job is to try to lock for X seconds. if lock success then wait for Y seconds and release the mutex.
// we can see that if time X (time to try acquire lock) is less than time Y (time a thread wait when acquired a lock), then one thread will not be able to acquire the lock and will fail to enter.
// X=1, Y=2 -> thread 2 will fail and thread 1 will succeed.
// X=2, Y=1 -> both threads succeed
// X=1, Y=1 -> !! unexpected !!
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

int amount = 0;
int X=2, Y=1;
std::timed_mutex m;

void increment(int i) {
	if (m.try_lock_for(std::chrono::seconds(X))) {
		++amount;
		std::this_thread::sleep_for(std::chrono::seconds(Y));
		cout << "thread " << i << " entered" << endl;
		m.unlock();
	} else {
		cout << "thread " << i << " failed to enter" << endl;
	}
}

int main() {
	
	std::thread t1(increment, 1);
	std::thread t2(increment, 2);
	
	t1.join();
	t2.join();
	
	cout << amount << endl;
	return 0;
}
//------------------




//------------------
// Recursive Mutex In C++ Threading
// 01:32:51 - 
// 7. std::recursive_mutex::try_lock
// this mutex allows the same thread to lock the same mutex multiple times. this is opposed to the regular mutex where if lock is called again will cause a runtime failure.
// if thread X has locked mutex M for N times, it will HAVE TO unlock it for N times. until then, mutex M will be considered locked for all other threads and they won't be able to lock it themselves.
// the amount of recursive locks that is allowed is undefined but if reached, then it will return "std:system_error" in case we call "lock" and will return false if we call "try_lock"
// it is advised to avoid using it if not neccessary
//------------------

#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

std::recursive_mutex m1;
int buff = 0;

// Example 1: using recursion
void recursion(char c, int loopFor) {
	if (loopFor<0)
		return;
	
	m1.lock();
	cout << "thread " << c << " " << buff++ << endl;
	recursion(c, --loopFor);
	m1.unlock();
	cout << "unlock by thread " << c << endl;
}

// Example 2: using loop
void loop(char c, int loopFor) {
	for (int i=0; i<loopFor; ++i) {
		m1.lock();
		cout << "lock by thread " << c << endl;
	}
	for (int i=0; i<loopFor; ++i) {
		m1.unlock();
		cout << "unlock by thread " << c << endl;
	}
}

int main() {
	
	// Example 1: using recursion
	std::thread t1(recursion, 'A', 1000);
	std::thread t2(recursion, 'B', 1000);
	t1.join();
	t2.join();
	
	// Example 2: using loop
	std::thread t3(loop, 'C', 1000);
	std::thread t4(loop, 'D', 1000);
	t3.join();
	t4.join();
	
	return 0;
}


//------------------




//------------------
// Lock Guard In C++ Threading
// 01:53:21 - 
// syntax: "std::lock_guard<std::mutex> myLockGuard(myMutex)"
// lock_guard is a lightweight wrapper that owns a mutex in certain scope
// once created, it automatically locks the mutex.
// once goes out of scope (and thus destroyed), it automatically unlocks the mutex.
// does not allow direct unlock to the mutex it owns, and it cannot be copied.
// the example below shows that we want to unlock just before exiting the task, so instead of using regular "unlock" at the end, we can just use a lock_guard, and we can be sure it will unlock when exiting the task since it goes out of scope and thus releasing the mutex.
//------------------
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

std::mutex m1;
int buff = 0;

void task(const char* threadNum, int loopFor) {
	std::lock_guard<mutex> lg(m1); // wrap our mutex and acquire lock
	for (int i=0; i<loopFor; ++i) {
		buff++;
		cout << "thread: " << threadNum << " buffer: " << buff << endl;
	}
	// implicitly unlock the mutex at exit
}

int main() {
	std::thread t1(task, "1", 50);
	std::thread t2(task, "2", 50);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------




//------------------
// Unique Lock In C++ Threading
// 02:02:14 - 
// syntax: "std::unique_lock<std::mutex> myUniqueLock(myMutex, (optional)STRATEGY)"
// unique_lock is a class of a mutex ownership. it is also a wrapper.
// similarly 
// provides:
// 1. using multiple locking strategies:
// 2. timed locking attempts (try_lock_for & try_lock_until)
// 3. recursive locking
// 4. transfer of lock ownership (moving of the lock, NOT copying it)
// 5. condition variables.
// locking strategies:
//		TYPE			EFFECT
//		----			------
// 0. 					no strategy
// 1. defer_lock		do not acquire ownership of the mutex
// 2. try_to_lock		try to acquire ownership of the mutex without blocking
// 3. adopt_lock		assume the calling thread already have ownership on the mutex.
//------------------
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

std::mutex m1;
int buff = 0;

// e.x. 1: no strategy
void task__1(const char* threadNum, int loopFor) {
	std::unique_lock<mutex> ul(m1); // auto lock here
	for (int i=0; i<loopFor; ++i) {
		buff++;
		cout << "thread: " << threadNum << " buffer: " << buff << endl;
	}
	// implicit unlock here on unique_lock destructor
}

// e.x. 2: defer_lock
void task__2(const char* threadNum, int loopFor) {
	std::unique_lock<mutex> ul(m1, std::defer_lock); // just ownership, no lock
	ul.lock(); // manuall lock it here (lock on the owner, NOT the mutex itself!)
	for (int i=0; i<loopFor; ++i) {
		buff++;
		cout << "thread: " << threadNum << " buffer: " << buff << endl;
	}
	// implicit unlock here on unique_lock destructor
}

// e.x. 3: try_to_lock
void task__3(const char* threadNum, int loopFor) {
	std::unique_lock<mutex> ul(m1, std::try_to_lock); // try to take ownership and lock
	if (ul.owns_lock()) {
		for (int i=0; i<loopFor; ++i) {
			buff++;
			cout << "thread: " << threadNum << " buffer: " << buff << endl;
		}
	}
	// implicit unlock here on unique_lock destructor
}

// e.x. 4: adopt_lock
void task__4(const char* threadNum, int loopFor) {
	m1.lock(); // lock  manually before taking ownership (lock the mutex itself! NOT the unique_lock object
	std::unique_lock<mutex> ul(m1, std::adopt_lock); // take ownership only. assume the mutex already locked
	/*
	//the two lines above are equivalent to:
	std::unique_lock<mutex> ul(m1, std::defer_lock);
	ul.lock();
	*/
	if (ul.owns_lock()) {
		for (int i=0; i<loopFor; ++i) {
			buff++;
			cout << "thread: " << threadNum << " buffer: " << buff << endl;
		}
	}
	// implicit unlock here on unique_lock destructor
}

int main() {
	
	// e.x. 1: no strategy
	std::thread t1(task__1, "1", 50);
	std::thread t2(task__1, "2", 50);
	t1.join();
	t2.join();
		
	// e.x. 2: defer_lock
	buff = 0;
	std::thread t3(task__2, "3", 50);
	std::thread t4(task__2, "4", 50);
	t3.join();
	t4.join();
		
	// e.x. 3: try_to_lock
	buff = 0;
	std::thread t5(task__3, "5", 500);
	std::thread t6(task__3, "6", 500);
	t5.join();
	t6.join();
		
	// e.x. 4: adopt_lock
	buff = 0;
	std::thread t7(task__4, "7", 50);
	std::thread t8(task__4, "8", 50);
	t7.join();
	t8.join();
	
	return 0;
}
//------------------




//------------------
// Condition Variable In C++ Threading
// 02:13:49 - 
// allows notifying other threads, effectively synchronizing them
// allows a thread to wait for a condition to occur
// most common use-case is the "producer<->consumer" paradygm.
// threads are notified using "notify_one()" and "notify_all()"
// it requires a mutex object in order to work
// A thread wishing to wait for a condition to occur will follow these steps:
// 1. aquire the mutex lock using "std::unique_lock<std::mutex> ul(m)"
// 2. call "wait", "wait_for" or "wait_until". this wait operations atomically release the mutex and suspends the execution of the current thread. 
//    we pass the CONDITION PREDICATE as a parameter to the wait call.
//    syntax: "myConditionVariable.Wait(myMutex, CONDITION_PREDICATE);"
// 3. once the condition defined in the condition variable is met, the thread resumes and the mutex is atomically re-acquired. it is recommended for that thread to manually check for that condition itself, to avoid spurious wakes.
//------------------

//the example below shows a simple case where one thread is trying to withdraw money from an account, and another thread is trying to add money to the account. the withdraw thread starts first and the main thread waits some time and only then starts the second thread which adds money. money cannot be withdrawed if the balance is insufficient so the withdraw thread waits before attempting its action, and waits for a notification from the add money thread before it attempts to withdraw
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
using namespace std;

std::condition_variable cv;
std::mutex m;
long balance = 0;

void addMoney(int amount) {
	cout << "attempting to add " << amount << " to balance..." << endl;
	std:lock_guard<mutex> lg(m);
	balance += amount;
	cout << "amount added to current balance: " << balance << endl;
	cv.notify_one();  // using "notify_one" since only one thread waits.
}

void withdrawMoney(int amount) {
	cout << "attempting to withdraw " << amount << " from balance..." << endl;
	std::unique_lock<mutex> ul(m);
	cv.wait(ul,
	// the CONDITION PREDICATE. while false it will keep waiting 
	[] { return (balance != 0) ? true : false; } 
	);
	if (balance >= amount) {
		balance -= amount;
		cout << "amount deducted: " << amount << endl;
	} else {
		cout << "amount " << amount << " cannot be deducted, balance of " << balance << " is insufficient." << endl;
	}
	cout << "current balance is: " << balance << endl;
}

int main() {
	
	std::thread t1(withdrawMoney, 450);
	std::this_thread::sleep_for(std::chrono::seconds(2));
	std::thread t2(addMoney, 500);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------




//------------------
// DeadLock With Example In C++
// 02:28:14 - 
// A situation where two threads are waiting for each other to release a resource that they require in order to continue.
//------------------

// the example below shows a very simple deadlock situation
// we have two threads and two mutexes. each thread require both mutexes to be locked in order to execute its critical section and then release the mutexes.
// thread 1 locks mutex 1 then wait for X microseconds and then it locks mutex 2
// thread 2 locks mutex 2 then wait for X microseconds and then it locks mutex 1
// the problem occurs if
// - thread 1 locks mutex 1 and before locking mutex 2, thread 2 locks mutex 2
//    OR (the opposite)
// - thread 2 locks mutex 2 and before locking mutex 1, thread 1 locks mutex 1
// the result is that thread 1 is waiting for mutex 2 to be released by thread 2 & thread 2 is waiting for mutex 1 to be released by thread 1.
// Note that we cannot predict if and when this will happen but it CAN happen.
// to force it to happen, we insert a delay for each thread, after it locks its own mutex (thread 1 locks mutex 1 and thread 2 locks mutex 2). if the delay is large enough then a deadlock is sure to happen every time. 
// a 1 second delay is sure to make it happen every time
// * a simple solution is to just flip the lock order in one of the thread tasks so it will match the order of the second one.
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

std::mutex m1;
std::mutex m2;

int lockingDelayus = 1000;

void thread1() {
	cout << "enter thread 1" << endl;
	m1.lock();
	cout << "mutex 1 locked by thread 1" << endl;
	std::this_thread::sleep_for(std::chrono::microseconds(lockingDelayus));
	m2.lock();
	cout << "critical section in thread 1" << endl;
	m1.unlock();
	m2.unlock();
}
void thread2() {
	cout << "enter thread 2" << endl;
	m2.lock();
	cout << "mutex 2 locked by thread 2" << endl;
	std::this_thread::sleep_for(std::chrono::microseconds(lockingDelayus));
	m1.lock();
	cout << "critical section in thread 2" << endl;
	m2.unlock();
	m1.unlock();
}

int main() {
	
	std::thread t1(thread1);
	std::thread t2(thread2);
	t1.join();
	t2.join();
	
	return 0;
}
//------------------




//------------------
// Synchronisation (demonstrated with threads, but applies to processes sync also)
// 02:36:57 - 
// this demonstrates the simple concept of critical section, which is a set of commands that must be executed by one thread at a time.
// a critical section MUST contain a WRITE command. reading a value is not considered a critical section (if nothing is returned from the task, which is common). this means that we must synchronize commands that write on shared variables.
//------------------
// the example shows two threads trying to read a shared variable. without proper sync method, and although very rare, a situation might happen that both threads will arrive at the first line of the task at the same time and both will read the balance as 0 and thus the final balance will not be 300.
// use the "USE_SYNC" to add or remove the sync code to see the result.
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

// USE_SYNC == 0  -> no sync - will produce errors
// USE_SYNC == 1  -> with sync - no errors will be produced
#define USE_SYNC 0

#if USE_SYNC
std::mutex m;
#endif

typedef long long ll;
ll bankBalance = 0;

void addMoney(ll val) {
#if USE_SYNC
	m.lock();
#endif
	bankBalance+=val;
#if USE_SYNC
	m.unlock();
#endif
}

int main() {
	
	for (int i=0; i<10000; ++i) {
	    bankBalance = 0;
		std::thread t1(addMoney, 100);
		std::thread t2(addMoney, 200);
		t1.join();
		t2.join();
	    if (bankBalance < 300)
	        cout << "iteration " << i << ": ERROR!. balance: " << bankBalance << endl;
	}
	return 0;
}
//------------------




//------------------
// std::lock In C++11
// 02:50:46 - 
// syntax: std::lock(m1, m2, m3, ..., mn);
// a static function that is used to lock multiple mutex instances at the same time with one call.
// the lock attempts are done in iterations where when an iteration fails to lock all mutexes, the function unlocks all mutexes that were successfully locked, and then starts a new lock attempt iteration
// within each successive iteration the mutexes are re-arrainged in such a way that mutexes that failed to get locked in previous iteration will be attempted to get locked FIRST.
// Notes:
// 1. the process of locking all passed mutexes uses a sequence of calls to "lock", "try_lock" and "unlock" on each mutex.
// 2. the ORDER of locking is UNKNOWN. the function will try to lock all given mutexes in ANY order, while ensuring that there's no dead-lock
// 3. this function is blocking, meaning the caller will wait indefinetly until lock is finished.
//
// Case examples:
// --------------
//
// 1. --> No dead-lock 
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2);			std::lock(m1,m2);
//
// 2. --> No dead-lock 
//        one of the threads will have multiple iterations
//        * in this case, if we lock each mutex on its own, we WILL have a dead-lock
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2);			std::lock(m2,m1);
//
// 3. --> No dead-lock 
//        thread 2 will lock m3&m4 first, so thread 1 will release m1 and m2 and will have multiple iterations
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2,m3,m4);		std::lock(m3,m4);
// 								std::lock(m1,m2);
//
// 4. --> A dead-lock ooccurs here 
//        when a "lock" call fails, it can only unlock the mutexes it got passed in. thread 1 locks m1&m2, thread 2 locks m3&m4, and at this point, they moved on to the next "lock" call. the previously locked mutexes cannot be freed now because they were locked by another lock call. this is certatain to result a dead-lock.
//		Thread 1				Thread 2		
//		--------				--------
// 	std::lock(m1,m2);			std::lock(m3,m4);
// 	std::lock(m3,m4);			std::lock(m1,m2);
//
//------------------
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

std::mutex m1, m2, m3, m4;

void simulateWork() { std::this_thread::sleep_for(std::chrono::milliseconds(10)); }

void case1_t1Task() {
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock();
}
void case1_t2Task() {
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock();
}

void case2_t1Task() {
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock();
}
void case2_t2Task() {
	std::lock(m2,m1);
	simulateWork();
	m1.unlock(); m2.unlock();
}

void case3_t1Task() {
	std::lock(m1,m2,m3,m4);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}
void case3_t2Task() {
	std::lock(m3,m4);
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}

void case4_t1Task() {
	std::lock(m1,m2);
	std::lock(m3,m4);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}
void case4_t2Task() {
	std::lock(m3,m4);
	std::lock(m1,m2);
	simulateWork();
	m1.unlock(); m2.unlock(); m3.unlock(); m4.unlock();
}

int main() {
	
	// case1
	for (int i=0; i<100; i++) {
		std::thread t1(case1_t1Task); std::thread t2(case1_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 1: " << "finished" << endl;
	
	// case2
	for (int i=0; i<100; i++) {
		std::thread t1(case2_t1Task); std::thread t2(case2_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 2: " << "finished" << endl;
	
	// case3
	for (int i=0; i<100; i++) {
		std::thread t1(case3_t1Task); std::thread t2(case3_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 3: " << "finished" << endl;
	
	// case4
	for (int i=0; i<100; i++) {
		std::thread t1(case4_t1Task); 
		simulateWork();  // insert some delay to allow t1 to lock all mutexes. if this delay is removed, a dead-lock will occur
		std::thread t2(case4_t2Task);
		t1.join(); t2.join();
	}
	cout << "case 4: " << "finished" << endl;
	
	return 0;
}
//------------------




//------------------
// std::promise And std::future In C++ Threading and why to use them?
// 03:10:02 - 
// promise is used to set values or throw exceptions
// future is used to get data from a promise, check for avaiable data, and wait for the promise to provide data.
// the promise defines the data that it suppose to provide.
// the promise is passed as an argument to the thread job func with "std::move(myPromise)", and is received in the func signature with the syntax "std::promise<myDataType>&& myPromiseParameter"
// when the promise have the data, it signals the future with "myPromise.set_value(myValue)" method.
// the future object is provided by the promise object
// we use the future to wait for the promise value by using "myFuture.get()" method.
// as recommended. we join the thread before main is finished, EVEN though we know for sure the thread has finished!
//------------------
#include <iostream>
#include <thread>
#include <chrono>
#include <algorithm>
#include <future>
using namespace std;
using namespace std::chrono;

typedef long int ull;

void findOdd(std::promise<ull>&& oddSumPromise, ull start, ull end) {
	ull oddSum = 0;
	for (ull i=start; i<=end; ++i) {
		if (i & 1) {
			oddSum += i;
		}
	}
	oddSumPromise.set_value(oddSum);
}

int main() {
	
	ull start=0, end = 1900000000;
	
	std::promise<ull> oddSum;
	std::future<ull> oddFuture = oddSum.get_future();
	
	cout << "creating and starting a thread" << endl;
	std::thread t(findOdd, std::move(oddSum), start, end);
	cout << "waiting for the promise to be provided" << endl;
	
	cout << "oddSum: " << oddFuture.get() << endl;
	
	cout << "job completed" << endl;
	t.join();
	return 0;
}
//------------------




//------------------
// std::async In C++ Create A Task
// 03:18:20 - 
// executes a function asynchronically (can be within a new thread but not must be), and at task end it returns an "std::future" object that holds the result.
// it encapsulates the promise and future mechanism and simplifies it.
//
// launch policies:
// 1. std::launch::async
// 		-> start upon creation of the future object.
// 		-> the task will be executed in a new thread
// 2. std::launch::deferred
// 		-> start upon calling "get" function on the future object.
// 		-> the task will be executed on the main thread (no new thread)
// 3. std::launch::async | std::launch::deferred	
//		-> either or, let the computer decide
//
// How it works internally:
// 1. creates a new dedicated thread OR picks a thread from an internal thread-pool, and creates an "std::promise" object to control the sync.
// 2. it passes the "promise" object to the task function and returns the "future" object that is created from the promise.
// 3. when the task function exits, the value is set in the future object and the return value of that function will be contained in that object.
// Notes: 
// the task function can also be a functor or a lambda function.
// this is a very clean way to run a regular function in a thread - no need to change anything in the function, meaning we decoupled the threading mechanism from the logic of the function.
//------------------
#include <iostream>
#include <thread>
#include <chrono>
#include <algorithm>
#include <future>

using namespace std;
using namespace std::chrono;

typedef long int ull;

ull findOdd(ull start, ull end) {
	
	cout << "Task thread ID = " << std::this_thread::get_id() << endl;
	
	ull oddSum = 0;
	for (ull i=start; i<=end; ++i) {
		if (i&1) {
			oddSum += i;
		}
	}
	return oddSum;
}

int main() {
	
	ull start = 0, end = 1900000000;
	
	cout << "Main thread ID = " << std::this_thread::get_id() << endl;
	
	cout << "\nExample: policy = async" << endl;
	std::future<ull> oddSumResAsync = std::async(std::launch::async, findOdd, start, end);
	cout << "A thread starts upon creation. \n lets wait for a while and only then call \"get\" on the future object. the result will be immediate" << endl;
	cout << "main thread sleep for 5 seconds.." << endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(5000));
	cout << "sleep finished" << endl;
	cout << "waiting for the result.." << endl;
	cout << "oddSum: " << oddSumResAsync.get() << endl;
	cout << "complete." << endl;
	
	cout << "\nExample: policy = deferred" << endl;
	std::future<ull> oddSumResDeferred = std::async(std::launch::deferred, findOdd, start, end);
	cout << "The task starts when calling \"get\" on the future object. note that it executes on the main thread!. \n lets wait for a while and only then call \"get\" on the future object. the result will take some time" << endl;
	cout << "main thread sleep for 5 seconds.." << endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(5000));
	cout << "sleep finished" << endl;
	cout << "waiting for the result.." << endl;
	cout << "oddSum: " << oddSumResDeferred.get() << endl;
	cout << "complete." << endl;
	
	return 0;
}
//------------------




//------------------
// Producer And Consumer Problem In C++ With Code Implementation
// 03:29:08 - 
// This is a know problem in thread oriented programming
// A producer produces data that is saved into a limited buffer.
// A consumer consumes data within the buffer when available. 
// Both producer and consumer are MODIFYING (writing) the buffer. producer inserts data while consumer removes data, so to synchronizes this mechanism we must use a mutex. 
// There can be multiple producers as well as multiple consumers. We'll focus on the simple case of one producer and one consumer.
// To implement this we need a mutex and a condition variable to add further condition on when the consumer should consume (the buffer is not empty), and when the producer should produce data into the buffer (the buffer is not full
// when producer produce it notifies the consumer. when the consumer consume it notifies the producer.
// the "problem" is that the order of the sequence of both producer and consumer taking over the buffer is unexpected. if we consider limit the producer (add a small delay between each production cycle), it is an inefficient use of the system capabilities. 
//------------------

// this example shows the simple case described above. 
// The PRODUCER gets a value from which it produces values from that value until 0, and then exits. 
// it first try to lock the mutex using a unique_lock object and then waits for a notification from the consumer using the condition variable. 
// once a notification arrives, the condition "buffer is not full" is checked  and if met it tries to lock the mutex. then it pushes the value to the buffer, unlocks the mutex and finally notify the consumer that it can have his turn
// The CONSUMER enters an infinite loop where on each iteration it waits for a notification from the producer using the same mutex and condition variable instances, but with the "buffer not empty" condition.
// upon notification it then locks the mutex and dequeue the last value pushed (FILO), unlocks the mutex and finally notifies the producer.
// NOTE - on each execution of the code, the order of producing and consuming is unexpected!. 
// if we make the producer sleep a little bit in between production cycles, the order is then expected but is inefficient

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <deque>
using namespace std;

std::mutex mu;
std::condition_variable cv;
deque<int> buffer;  // a queue-like buffer. basically circular
const unsigned int maxBuffSize = 50;

void producer_task(int value) {
	while (value) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() < maxBuffSize;
		} );
		buffer.push_back(value);
		cout << "Produced value: " << value << endl;
		--value;
		ul.unlock();
		cv.notify_one();
		// limit the producer to allow the consumer to get values before the buffer is full
		//std::this_thread::sleep_for(std::chrono::milliseconds(1));  
	}
}

void consumer_task() {
	while (1) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() > 0;
		} );
		int value = buffer.back();
		buffer.pop_back();
		cout << "Consumed value: " << value << endl;
		ul.unlock();
		cv.notify_one();
	}
}

int main() {
	std::thread producerThread(producer_task, 100);
	std::thread consumerThread(consumer_task);
	producerThread.join();
	consumerThread.join();
	
	return 0;
}


// this example shows the case where we have one producer and two consumers.
// the difference is we create two consumer threads with the same task, and also when the producer notifies, it notifies all, not one, though it seems to not have a big difference with the sequence. 
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <deque>
using namespace std;

std::mutex mu;
std::condition_variable cv;
deque<int> buffer;  // a queue-like buffer. basically circular
const unsigned int maxBuffSize = 50;

void producer_task(int value) {
	while (value) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() < maxBuffSize;
		} );
		buffer.push_back(value);
		cout << "Produced value: " << value << endl;
		--value;
		ul.unlock();
		cv.notify_all();
		// limit the producer to allow the consumer to get values before the buffer is full
		//std::this_thread::sleep_for(std::chrono::milliseconds(1));  
	}
}

void consumer_task(int threadID) {
	while (1) {
		std::unique_lock<std::mutex> ul(mu);
		cv.wait(ul, []() {
			return buffer.size() > 0;
		} );
		int value = buffer.back();
		buffer.pop_back();
		cout << "Consumer " << threadID << " Consumed value: " << value << endl;
		ul.unlock();
		cv.notify_one();
	}
}

int main() {
	std::thread producerThread(producer_task, 1000);
	std::thread consumerThread1(consumer_task, 1);
	std::thread consumerThread2(consumer_task, 2);
	producerThread.join();
	consumerThread1.join();
	consumerThread2.join();
	
	return 0;
}
//------------------





//------------------
// Sleep VS Wait In Threading, when to use what?
// 03:44:44 - 
// "Sleep": a notification from a thread to the OS to dismiss its execution timeslice, fora specified time (or more time). while sleeping, the OS doesn't try to scheduale more execution time for that thread, until specified sleep time elapses
// -> sleep will KEEP THE LOCK while sleeping. - blocking
// -> sleep is a thread function.
// "Wait": a notification from a thread to the OS to dismiss its execution timeslice until other threads notify the thread (through notify_one or notify_all), at which point the thread can test a specified condition. while waiting, the OS doesn't try to scheduale more execution time for that thread, until the thread is being notified through a shared sync object (or some wakeup scenarios occur)
// -> wait RELEASES THE LOCK and then waits - non-blocking
// -> wait is applied to a condition variable which puts the thread into wait state.
//------------------
#include <iostream>

int main() {
	return 0;
}
//------------------







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------